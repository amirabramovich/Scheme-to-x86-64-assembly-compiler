    let diffRibs param body occs =
      let getVar param occ =

      let ribsIter param body occs idx =
        let curr = List.nth occs idx in
        let rest = List.filter (fun occ -> occ != curr) occs in
        let var = getVar param curr in
        match var with
          | VarParam v -> 
          | VarBound v ->


              let diffRibs param body occs =
      let getType param occ =
        match occ with
        | Var' var ->   
          match var with
            | VarParam(name, pos) -> 'p'
            | VarBound(name, depth, pos) -> 'b'
        | _ -> X_not_yet_implemeted
        (* rest of expr' .. *)

         let first = List.nth occs 0 in
      let second = List.nth occs 1 in
      getType param first != getType param second




      
    (* Return (body, ansentor) if it has write occ' of param *)
    let getWrites param body = 
      (* Return true if has write occ' *)
      let isWrite param body = (getWrites != [])
      in
      match body with
      (* Base case, if body match Set' and var = param => body, else => [] *)
      | Set'(Var' var, value) ->
        match var with
          | VarParam(name, pos) | VarBound(name, depth, pos) -> if param = name then body else []
      (* Check write in all exprs *)
      | Seq' exprs -> if (List.filter (fun expr -> isWrite param expr) exprs) != [] then body else []
      (* Check write recursively in bodies *)
      | LambdaSimple'(params, currBody) | LambdaOpt'(params, op, currBody) -> if isWrite param currBody then body else []
      | _ -> []
    in

    (* Return true if occ's list contains occurrences of different ribs *)
    let diffRibs param body occs = X_not_yet_implemented in

    (* Reads & Writes closures *)
    let reads = getReads param body in
    let writes = getWrites param body in
    (* Filter reads, return all reads that not occur in write *)
    let readsDiff = List.filter (fun read -> not (List.mem read writes)) reads in
    (* Filter writes, return all writes that not occur in read *)
    let writesDiff = List.filter (fun write -> not (List.mem write reads)) writes in
    (* let occs = readsDiff @ writesDiff in *)
    (* List.exist (not sameRib) diff *)
    (* diffRibs param body occs *)







    SAVE IT !

    
        (* Return body if it has read occ' of param *)
    (* Idea: return Pair(body, ancestor) => ability to compare ancestors *)
    let rec getReads param body = 
      (* Return true if has read occ' *)
      let isRead param body = (getReads param body) != [] in
      let getAncestor param body = raise X_not_yet_implemented in
      let ancestor = getAncestor param body in
      (match body with
        (* Base case, body match var and var = param => body, else => [] *)
        | Var' var ->
          (match var with
            | VarParam(name, pos) -> if param = name then [body] else []
            | VarBound(name, depth, pos) -> if param = name then [body] else []
            | _ -> [])
        (* Check reads in values *)
        | Set'(var, value) -> if isRead param value then [body] else []
        | Def'(name, value) -> if isRead param value then [body] else []
        (* Check reads in all exprs *)
        | Or' exprs -> if (List.filter (fun expr -> isRead param expr) exprs) != [] then [body] else []
        | If'(test, dit, dif) -> if (isRead param test) || (isRead param dit) || (isRead param dif) then [body] else []
        | Seq' exprs -> if (List.filter (fun expr -> isRead param expr) exprs) != [] then [body] else []
        (* Check reads in exprs *)
        | Applic'(op, exprs) | ApplicTP'(op, exprs) -> if (List.filter (fun expr -> isRead param expr) exprs) != [] then [body] else []
        (* Check reads recursively in bodies *)
        | LambdaSimple'(params, currBody) -> if isRead param currBody then [body] else []
        | LambdaOpt'(params, op, currBody) -> if isRead param currBody then [body] else []
        | _ -> [])
    in

    (* Return (body, ansentor) if it has write occ' of param *)
    let rec getWrites param body = 
      (* Return true if has write occ' *)
      let isWrite param body = (getWrites param body != []) in
      (match body with
        (* Base case, if body match Set' and var = param => body, else => [] *)
        | Set'(Var' var, value) ->
          (match var with
            | VarParam(name, pos) -> if param = name then [body] else []
            | VarBound(name, depth, pos) -> if param = name then [body] else [])
        (* Check write in all exprs *)
        | Seq' exprs -> if (List.filter (fun expr -> isWrite param expr) exprs) != [] then [body] else []
        (* Check write recursively in bodies *)
        | LambdaSimple'(params, currBody) -> if isWrite param currBody then [body] else []
        | LambdaOpt'(params, op, currBody) -> if isWrite param currBody then [body] else []
        | _ -> [])
    in

    (* Return true if occ's list contains occurrences of different ribs *)
    let diffRibs param body occs = X_not_yet_implemented in

    (* Reads & Writes closures *)
    let reads = getReads param body in
    let writes = getWrites param body in
    (* Filter reads, return all reads that not occur in write *)
    let readsDiff = List.filter (fun read -> not (List.mem read writes)) reads in
    (* Filter writes, return all writes that not occur in read *)
    let writesDiff = List.filter (fun write -> not (List.mem write reads)) writes in
    diffRibs param body (readsDiff @ writesDiff)
  in




    (* let repSet param body = 
    match body with
      | Set'(Var'(VarParam(v, pos)), value) -> if param = v then BoxSet'(VarParam(v, pos), value) else body
      | Set'(Var'(VarBound(v, depth, pos)), value) -> if param = v then BoxSet'(VarBound(v, depth, pos), value) else body
      | _ -> body
  in *)


    (* let repGet param body = 
    match body with
      | Var' (VarParam(v, pos)) -> if param = v then BoxGet'(VarParam(v, pos)) else body
      | Var' (VarBound(v, depth, pos)) -> if param = v then BoxGet'(VarBound(v, depth, pos)) else body
      | _ -> body
  in *)



***********


  9.12


  let box_set e = 
  
  (* TODO: check pos of param *)
  let addSet param body =
    match body with
      | Seq' exprs -> Seq' ([Set' (Var' (VarParam(param, 0)), Box' (VarParam(param, 0)))] @ exprs)
      | _ -> Seq' [Set' (Var' (VarParam(param, 0)), Box' (VarParam(param, 0))); body]
  in

  (* Replace set occur's of param in body *)
  let rec repGet param body = 
    match body with
      (* Base case *)
      | Var' (VarParam(v, pos)) -> if param = v then BoxGet'(VarParam(v, pos)) else body
      | Var' (VarBound(v, depth, pos)) -> if param = v then BoxGet'(VarBound(v, depth, pos)) else body
      (* Replace values *)
      | Set'(var, value) -> Set'(repGet param var, repGet param value)
      | Def'(name, value) -> Def'(name, repGet param value)
      | BoxSet' (var, value) -> BoxSet' (var, repGet param value)
      (* Replace all exprs *)
      | Or' exprs -> Or'(List.map (fun expr -> repGet param expr) exprs)
      | If'(test, dit, dif) -> If'(repGet param test, repGet param dit, repGet param dif)
      | Seq' exprs -> Seq' (List.map (fun expr -> repGet param expr) exprs)
      (* Replace exprs *)
      | Applic'(op, exprs) -> Applic'(repGet param op, (List.map (fun expr -> repGet param expr) exprs))
      | ApplicTP'(op, exprs) -> ApplicTP'(repGet param op, (List.map (fun expr -> repGet param expr) exprs))
      (* Replace bodies recursively *)
      | LambdaSimple'(params, currBody) -> if (List.mem param params) then LambdaSimple' (params, currBody) 
                                                                      else LambdaSimple' (params, repGet param currBody)
      | LambdaOpt'(params, op, currBody) -> if (List.mem param (op :: params)) then LambdaOpt' (params, op, currBody) 
                                                                               else LambdaOpt'(params, op, repGet param currBody)
      | _ -> body 
  in

  (* Replace get occur's of param in body *)
  let rec repSet param body = 
    match body with
      | Set' (Var'(VarParam(v, pos)), value) -> if param = v then BoxSet'(VarParam(v, pos), repSet param value) 
                                                else Set' (Var' (VarParam (v, pos)), repSet param value)
      | Set' (Var'(VarBound(v, depth, pos)), value) -> if param = v then BoxSet'(VarBound(v, depth, pos), repSet param value) 
                                                                    else Set' (Var' (VarBound (v, depth, pos)), repSet param value)
      | Set' (Var' v, value) -> Set' (Var' v, repSet param value)
      | BoxSet' (var, value) -> BoxSet' (var, repSet param value)
      | If' (test, dit, dif) -> If' (repSet param test, repSet param dit, repSet param dif)
      | Def' (name, value) -> Def' (name, repSet param value)
      | Seq' exprs -> Seq' (List.map (repSet param) exprs)
      | Or' exprs -> Or' (List.map (repSet param) exprs)
      | Applic'(op, exprs) -> Applic'	(repSet param op, List.map (repSet param) exprs)
      | ApplicTP'(op, exprs) -> ApplicTP' (repSet param op, List.map (repSet param) exprs)
      | LambdaSimple' (params, body) -> if (List.mem param params) then LambdaSimple' (params, body) 
                                                                   else LambdaSimple' (params, repSet param body)
      | LambdaOpt' (params, op, body) -> if (List.mem param (op :: params)) then LambdaOpt' (params, op, body) 
                                                                            else LambdaOpt' (params, op, repSet param body)
      | _ -> body 
  in

  (* Got body, toBox list -> return boxed body *)
  let boxThem body toBox =
    let set = List.fold_right (fun param currBody -> repSet param currBody) toBox body in
    let get = List.fold_right (fun param currBody -> repGet param currBody) toBox set in
    let aset = List.fold_right (fun param currBody -> addSet param currBody) toBox get in aset
  in

  (* Return read expr' list if exist, and [Const' Void] otherwise *)
  let rec read param body =
    match body with
      | Var'(VarParam(v, pos)) -> if param = v then [body] else [Const' Void]
      | Var'(VarBound(v, depth, pos)) -> if param = v then [body] else [Const' Void]
      | LambdaSimple' (params, currBody) -> read param currBody
      | Applic'(op, exprs) -> read param op @ List.flatten (List.map (fun expr -> read param expr) exprs)
      | ApplicTP'(op, exprs) -> read param op @ List.flatten (List.map (fun expr -> read param expr) exprs)
      | _ -> [Const' Void]
  in

  (* Return read expr' or Const' Void *)
  let readB param body =
    let lst = read param body in
    let final = List.filter (fun (elem) -> (elem <> (Const' Void))) lst in
    if final <> [] then List.nth final 0 else Const' Void
  in

  (* Return write expr' list or Const' Void list *)
  let rec write param body =
    match body with
      | Set'(Var'(VarParam(v, pos)), value) -> if v = param then [body] else [Const' Void]
      | Set'(Var'(VarBound(v, depth, pos)), value) -> if v = param then [body] else [Const' Void]
      | LambdaSimple' (params, currBody) -> write param currBody
      | Applic'(op, exprs) -> write param op @ List.flatten (List.map (fun expr -> write param expr) exprs)
      | ApplicTP'(op, exprs) -> write param op @ List.flatten (List.map (fun expr -> write param expr) exprs)
      | _ -> [Const' Void]
  in

  (* Return write expr' or Const' Void *)
  let writeB param body =
    let lst = write param body in
    let final = List.filter (fun (elem) -> (elem <> (Const' Void))) lst in
    if final <> [] then List.nth final 0 else Const' Void
  in
  
  (* Return true if param is bound in body, and false otherwise *)
  let rec isBound param body = 
    match body with
      | Var' (VarBound (par, _, _)) -> par = param
      | Def' (var, expr) | Set' (var, expr) -> isBound param var || isBound param expr
      | If' (test, dit, dif) -> isBound param test || isBound param dit || isBound param dif
      | BoxSet' (_, expr) -> isBound param expr
      | Seq' exprs | Or' exprs -> ormap (isBound param) exprs
      | Applic' (op, exprs) | ApplicTP' (op, exprs) -> isBound param op || ormap (fun e -> isBound param e) exprs
      | LambdaSimple' (params, body) -> if (List.mem param params) then false else isBound param body
      | LambdaOpt' (params, opt, body) -> if (List.mem param (opt :: params)) then false else isBound param body
      | _ -> false 
  in

  let ancestor param body occurenceBody = isBound param occurenceBody in

  (* Got param and body, return true if param should be boxed, and false otherwise *)
  (* TODO: cover more cases *)
  let shouldBox param body = 
    let reads = readB param body in if reads = Const' Void then false else
    let writes = writeB param body in if writes = Const' Void then false else
    let final = (reads <> writes) in final
    (* && (not (ancestor param body reads)) || (not (ancestor param body writes))  *)
  in

  (* TODO: delete later *)
  (*
  let debug str = annotate_lexical_addresses (tag_parse_expression (read_sexpr str)) in
  let debug2 str = run_semantics (tag_parse_expression (read_sexpr str)) in 
  *)

  let rec checker params body toBox = 
    match params with
    | [] -> (boxThem body toBox) 
    | car :: cdr -> checker cdr body (if (shouldBox car body) then (toBox @ [car]) else toBox) in
  let check args body = checker args body [] in
  let rec check_box e =
    match e with
    | Const' _ | Var' _ | Box' _ | BoxGet' _ -> e
    | If' (test, dit, dif) -> If' (check_box test, check_box dit, check_box dif)
    | Set' (var, value) -> Set' (var, check_box value)
    | Def' (name, value) -> Def' (name, check_box value)
    | Seq' exprs -> Seq' (List.map check_box exprs)
    | Or' exprs -> Or' (List.map check_box exprs)
    | Applic' (op, exprs) -> Applic' (check_box op, List.map check_box exprs)
    | ApplicTP' (op, exprs) -> ApplicTP' (check_box op, List.map check_box exprs)
    | BoxSet' (var, expr) -> BoxSet' (var, check_box expr)
    | LambdaSimple' (args, body) -> LambdaSimple' (args, check_box (check args body)) 
    | LambdaOpt' (args, opt, body) -> raise X_not_yet_implemented
  in check_box e;;




****
  9.12 save for manual merge :

  (* Replace all set occurences of param in body *)
  let rec repGet param body = 
    match body with
      (* Base case *)
      | Var' (VarParam(v, pos)) -> if param = v then BoxGet'(VarParam(v, pos)) else body
      | Var' (VarBound(v, depth, pos)) -> if param = v then BoxGet'(VarBound(v, depth, pos)) else body
      (* Replace values *)
      | Set'(var, value) -> Set'(repGet param var, repGet param value)
      | Def'(name, value) -> Def'(name, repGet param value)
      | BoxSet' (var, value) -> BoxSet' (var, repGet param value)
      (* Replace all exprs *)
      | Or' exprs -> Or'(List.map (fun expr -> repGet param expr) exprs)
      | If'(test, dit, dif) -> If'(repGet param test, repGet param dit, repGet param dif)
      | Seq' exprs -> Seq' (List.map (fun expr -> repGet param expr) exprs)
      (* Replace exprs *)
      | Applic'(op, exprs) -> Applic'(repGet param op, (List.map (fun expr -> repGet param expr) exprs))
      | ApplicTP'(op, exprs) -> ApplicTP'(repGet param op, (List.map (fun expr -> repGet param expr) exprs))
      (* Replace bodies recursively *)
      | LambdaSimple'(params, currBody) -> if (List.mem param params) then LambdaSimple' (params, currBody) 
                                                                  else LambdaSimple' (params, repGet param currBody)  (* TODO: not opposite ? *)
      | LambdaOpt'(params, op, currBody) -> if (List.mem param (params @ [op])) then LambdaOpt' (params, op, currBody) 
                                                                                else LambdaOpt'(params, op, repGet param currBody)
      | _ -> body
  in

  (* Helper for box function *)
  let boxIt (param, pos) body = addSet (param, pos) (repGet param (repSet param body)) in

  (* Final Parse function, got expr', return boxed expr' *)
  let rec check_box e =
    match e with
      (* Base case => Box bodies *)
      | LambdaSimple' (args, body) -> LambdaSimple' (args, check_box (boxThem args body)) 
      | LambdaOpt' (args, opt, body) -> LambdaOpt' (args, opt, check_box (boxThem (args @ [opt]) body))
      (* Check recursively if need to box *)
      | If' (test, dit, dif) -> If' (check_box test, check_box dit, check_box dif)
      | Set' (var, value) -> Set' (var, check_box value)
      | Def' (name, value) -> Def' (name, check_box value)
      | Seq' exprs -> Seq' (List.map check_box exprs)
      | Or' exprs -> Or' (List.map check_box exprs)
      | Applic' (op, exprs) -> Applic' (check_box op, List.map check_box exprs)
      | ApplicTP' (op, exprs) -> ApplicTP' (check_box op, List.map check_box exprs)
      | BoxSet' (var, expr) -> BoxSet' (var, check_box expr)
      | _ -> e 
in check_box e;;



*******
9.12
notes

******
    (* let occs = [(findWriteB param body)] @ [(findReadB param body)] in
    let filt = List.filter (fun occ -> occ <> Const' Void) occs in
    let occ = if filt = [] then Const' Void else List.nth filt 0 in
    let anc = if not (isBound param occ) then Const' Void else getAncestor param body occ in anc *)


      (* Return true if param is bound in body, and false otherwise *)
  let rec isBound param body = 
    match body with
      | Var' (VarBound (par, _, _)) -> par = param
      | Def' (var, expr) | Set' (var, expr) -> isBound param var || isBound param expr
      | If' (test, dit, dif) -> isBound param test || isBound param dit || isBound param dif
      | BoxSet' (_, expr) -> isBound param expr
      | Seq' exprs | Or' exprs -> ormap (isBound param) exprs
      | Applic' (op, exprs) | ApplicTP' (op, exprs) -> isBound param op || ormap (fun e -> isBound param e) exprs
      | LambdaSimple' (params, body) -> if (List.mem param params) then false else isBound param body
      | LambdaOpt' (params, opt, body) -> if (List.mem param (params @ [opt])) then false else isBound param body
      | _ -> false 
  in


  (* Got param and occurence,
     If param present in occurence as Bound => Return depth of param,
     Otherwise => -1 *)
  (* TODO: add more cases *)
  let rec getDepth param occ =
    match occ with
      | Var' (VarBound (par, depth, _)) -> if param = par then depth else -1
      | Def' (vd, ed) -> getDepth param ed
      | Set' (vs, es) -> getDepth param vs
      | If'(test, dit, dif) -> max (max (getDepth param test) (getDepth param dit)) (getDepth param dif)
      | _ -> -1
  in
    


      (* Go "up" # depth levels of param occurence (occ) of read/write in body, and return the expr' (ancestor) *)
  (* let traverseLambda param body occ depth = *)

  (* let getAncestor param body occ = *)

  (* let ancestor param body =
    let reads = findReadB param body in
    let writes = findWriteB param body in
    (getAncestor param body reads) <> (getAncestor param body writes)
  in *)


   annotate_lexical_addresses (tag_parse_expression (read_sexpr "(define foo6
        (lambda (x)
          (lambda (op)
            (cond ((eq? op 'read) (lambda () x))
              ((eq? op 'write) (lambda (val) (set! x val)))))))
  "));;
- : expr' =
Def' (Var' (VarFree "foo6"),
 LambdaSimple' (["x"],
  LambdaSimple' (["op"],
   If'
    (Applic' (Var' (VarFree "eq?"),
      [Var' (VarParam ("op", 0)); Const' (Sexpr (Symbol "read"))]),
    LambdaSimple' ([], Var' (VarBound ("x", 1, 0))),
    If'
     (Applic' (Var' (VarFree "eq?"),
       [Var' (VarParam ("op", 0)); Const' (Sexpr (Symbol "write"))]),
     LambdaSimple' (["val"],
      Set' (Var' (VarBound ("x", 1, 0)), Var' (VarParam ("val", 0)))),
     Const' Void))) ))


  annotate_lexical_addresses (tag_parse_expression (read_sexpr "
     (define foo7 ( lambda ( x)annotate_lexical_addresses (tag_parse_expression (read_sexpr "(define foo1 (lambda (x)
                                                            (list (lambda () x)
                                                              (lambda (y) (set! x y)))))"))    ;;
- : expr' =
Def' (Var' (VarFree "foo1"),
 LambdaSimple' (["x"],
  Applic' (Var' (VarFree "list"),
   [LambdaSimple' ([], Var' (VarBound ("x", 0, 0)));
    LambdaSimple' (["y"],
     Set' (Var' (VarBound ("x", 0, 0)), Var' (VarParam ("y", 0))))])))
                    (
                      let ((y 1annotate_lexical_addresses (tag_parse_expression (read_sexpr "(define foo1 (lambda (x)
                                                            (list (lambda () x)
                                                              (lambda (y) (set! x y)))))"))    ;;
- : expr' =
Def' (Var' (VarFree "foo1"),
 LambdaSimple' (["x"],
  Applic' (Var' (VarFree "list"),
   [LambdaSimple' ([], Var' (VarBound ("x", 0, 0)));
    LambdaSimple' (["y"],
     Set' (Var' (VarBound ("x", 0, 0)), Var' (VarParam ("y", 0))))])))
                          `(,(lannotate_lexical_addresses (tag_parse_expression (read_sexpr "(define foo1 (lambda (x)
                                                            (list (lambda () x)
                                                              (lambda (y) (set! x y)))))"))    ;;
- : expr' =
Def' (Var' (VarFree "foo1"),
 LambdaSimple' (["x"],
  Applic' (Var' (VarFree "list"),
   [LambdaSimple' ([], Var' (VarBound ("x", 0, 0)));
    LambdaSimple' (["y"],
     Set' (Var' (VarBound ("x", 0, 0)), Var' (VarParam ("y", 0))))])))))) "));;

Def' (Var' (VarFree "foo7"),
 LambdaSimple' (["x"],
  Applic'
   (LambdaSimple' (["y"],
     Applic' (Var' (VarFree "cons"),
      [LambdaSimple' ([], Var' (VarBound ("x", 1, 0)));
       Applic' (Var' (VarFree "cons"),
        [Set' (Var' (VarBound ("x", 0, 0)), Var' (VarParam ("y", 0)));
         Const' (Sexpr Nil)])])),
   [Const' (Sexpr (Number (Int 1)))])))


   annotate_lexical_addresses (tag_parse_expression (read_sexpr "
      (define foo2 (lambda (x y)
                        (set! x (* x y))))"))    ;;
- : expr' =
Def' (Var' (VarFree "foo2"),
 LambdaSimple' (["x"; "y"],
  Set' (Var' (VarParam ("x", 0)),
   Applic' (Var' (VarFree "*"),
    [Var' (VarParam ("x", 0)); Var' (VarParam ("y", 1))]))))

     annotate_lexical_addresses ( (tag_parse_expression (read_sexpr
"(define foo8 (lambda (x y) (cons x (lambda () (set! x y)))))"))  );;
- : expr' =
Def' (Var' (VarFree "foo8"),
 LambdaSimple' (["x"; "y"],
  Applic' (Var' (VarFree "cons"),
   [Var' (VarParam ("x", 0));
    LambdaSimple' ([],
     Set' (Var' (VarBound ("x", 0, 0)), Var' (VarBound ("y", 0, 1))))])))


     annotate_lexical_addresses ((tag_parse_expression (read_sexpr "
      (define foo2 (lambda (x y)
                        (set! x (* x y))))")));;
- : expr' =
Def' (Var' (VarFree "foo2"),
 LambdaSimple' (["x"; "y"],
  Set' (Var' (VarParam ("x", 0)),
   Applic' (Var' (VarFree "*"),
    [Var' (VarParam ("x", 0)); Var' (VarParam ("y", 1))]))))

    annotate_lexical_addresses  (tag_parse_expression (read_sexpr "(define foo4 (lambda (x y)
                          (if x (lambda () (set! y x))
                                            (lambda (z) (set! x z)))))"))    ;;
- : expr' =
Def' (Var' (VarFree "foo4"),
 LambdaSimple' (["x"; "y"],
  If' (Var' (VarParam ("x", 0)),
   LambdaSimple' ([],
    Set' (Var' (VarBound ("y", 0, 1)), Var' (VarBound ("x", 0, 0)))),
   LambdaSimple' (["z"],
    Set' (Var' (VarBound ("x", 0, 0)), Var' (VarParam ("z", 0)))))))


    annotate_lexical_addresses (tag_parse_expression (read_sexpr "
                (define foo5
                        (lambda (x y)
                        (list (lambda () (set! x (+ x 1)))
                        (lambda () y))))" ))        ;;
- : expr' =
Def' (Var' (VarFree "foo5"),
 LambdaSimple' (["x"; "y"],
  Applic' (Var' (VarFree "list"),
   [LambdaSimple' ([],
     Set' (Var' (VarBound ("x", 0, 0)),
      Applic' (Var' (VarFree "+"),
       [Var' (VarBound ("x", 0, 0)); Const' (Sexpr (Number (Int 1)))])));
    LambdaSimple' ([], Var' (VarBound ("y", 0, 1)))])))

    annotate_lexical_addresses (tag_parse_expression (read_sexpr "(define foo1 (lambda (x)
                                                            (list (lambda () x)
                                                              (lambda (y) (set! x y)))))"))    ;;
- : expr' =
Def' (Var' (VarFree "foo1"),
 LambdaSimple' (["x"],
  Applic' (Var' (VarFree "list"),
   [LambdaSimple' ([], Var' (VarBound ("x", 0, 0)));
    LambdaSimple' (["y"],
     Set' (Var' (VarBound ("x", 0, 0)), Var' (VarParam ("y", 0))))])))


****

     10.12 tests

annotate_tail_calls (     annotate_lexical_addresses (tag_parse_expression (read_sexpr "
          (define foo6
            (lambda (x)
            (lambda (op)
            (cond ((eq? op 'read) (lambda () x))
            ((eq? op 'write) (lambda (val) (set! x val)))))))"))          );;
- : expr' =
Def' (Var' (VarFree "foo6"),
 LambdaSimple' (["x"],
  LambdaSimple' (["op"],
   If'
    (Applic' (Var' (VarFree "eq?"),
      [Var' (VarParam ("op", 0)); Const' (Sexpr (Symbol "read"))]),
    LambdaSimple' ([], Var' (VarBound ("x", 1, 0))),
    If'
     (Applic' (Var' (VarFree "eq?"),
       [Var' (VarParam ("op", 0)); Const' (Sexpr (Symbol "write"))]),
     LambdaSimple' (["val"],
      Set' (Var' (VarBound ("x", 1, 0)), Var' (VarParam ("val", 0)))),
     Const' Void)))))
#


    *******
    Removed prev version 9.12


  (* Return true if find read expr', otherwise, return false *)
  let rec read param body =
    match body with
      | Var'(VarParam(v, _)) | Var'(VarBound(v, _, _)) -> param = v
      | Def' (var, expr) | Set' (var, expr) -> read param var || read param expr
      | If' (test, dit, dif) -> read param test || read param dit || read param dif
      | Seq' exprs | Or' exprs -> ormap (read param) exprs
      | BoxSet' (_, expr) -> read param expr
      | Applic' (op, exprs) | ApplicTP' (op, exprs) -> read param op || ormap (read param) exprs
      | LambdaSimple' (params, body) -> if (List.mem param params) then false	else read param body
      | LambdaOpt' (params, opt, body) -> if (List.mem param (params @ [opt])) then false else read param body
      | _ -> false 
  in

  (* Return true if find write expr', otherwise, return false *)
  (* TODO: Check not read in same closure *)
  let rec write param body =
    match body with
      | Set' (Var' (VarParam (v, _)), expr) | Set' (Var' (VarBound (v, _, _)), expr) -> v = param || write param expr
      | Def' (var, expr) | Set' (var, expr) -> write param var || write param expr
      | If' (test, dit, dif) -> write param test || write param dit || write param dif
      | Seq' exprs | Or' exprs -> ormap (write param) exprs
      | BoxSet' (_, expr) -> write param expr
      | Applic' (op, exprs) | ApplicTP' (op, exprs) -> write param op || ormap (fun e -> write param e) exprs
      | LambdaSimple' (params, body) -> if (List.mem param params) then false else write param body
      | LambdaOpt' (params, opt, body) -> if (List.mem param (params @ [opt])) then false else write param body
      | _ -> false 
  in


  (* Returns true if param should be boxed and false otherwise *)
  (* TODO: add test of different closure *)1
  let shouldBox param body = (read param body) && (write param body) && (ancestor param body) in
  let shouldBox param body = (read param body) && (write param body) && (ancestor param body) in



**********************

  prev version 10.12 


    let rec check_box e =
    match e with
      (* Add check if body is Lambda *)
      | LambdaSimple' (args, body) -> LambdaSimple' (args, (boxThem args body))
      | LambdaOpt' (args, opt, body) -> LambdaOpt' (args, opt, (boxThem (args @ [opt]) body))
      | If' (test, dit, dif) -> If' (check_box test, check_box dit, check_box dif)
      | Set' (var, value) -> Set' (var, check_box value)
      | Def' (name, value) -> Def' (name, check_box value)
      | Seq' exprs -> Seq' (List.map check_box exprs)
      | Or' exprs -> Or' (List.map check_box exprs)
      | Applic' (op, exprs) -> Applic' (check_box op, List.map check_box exprs)
      | ApplicTP' (op, exprs) -> ApplicTP' (check_box op, List.map check_box exprs)
      | BoxSet' (var, expr) -> BoxSet' (var, check_box expr)
      | _ -> e 
  in check_box e;;



    let rec findWrites param body = 
    match body with
      (* Check not read in value in base case *)
      | Set'(Var'(VarParam(v, pos)), value) -> if ((findReads param value) = [] && v = param) then [body] else []
      | Set'(Var'(VarBound(v, depth, pos)), value) -> if ((findReads param value) = [] && v = param) then [body] else []
      (* Check not read in seq *)
      | Seq' exprs -> if (List.map (fun expr -> findReads param expr) exprs) <> [] then [] (* Check not read in same seq *)
        else List.flatten (List.map (fun expr -> findWrites param expr) exprs)
      | If' (test, dit, dif) -> List.flatten ([findWrites param test] @ [findWrites param dit] @ [findWrites param dif])
      | Def'(var, expr) -> findWrites param expr
      | Applic'(op, exprs) -> findWrites param op @ List.flatten (List.map (fun expr -> findWrites param expr) exprs)
      | ApplicTP'(op, exprs) -> findWrites param op @ List.flatten (List.map (fun expr -> findWrites param expr) exprs)
      (* TODO: add case of nested lambda => avoid case of read & write, Check foo: 3, 6, 7 *)
      | LambdaSimple' (params, currBody) ->
        if (List.exists (fun p -> p = param) params) then
          (match currBody with
            | LambdaSimple' (p, b) -> if findReads param b <> [] then [] else findWrites param b
            | LambdaOpt' (p, o, b) -> if findReads param b <> [] then [] else findWrites param b
            | _ -> findWrites param currBody)
        else findWrites param currBody
      | LambdaOpt' (params, opt, currBody) -> findWrites param currBody
      | _ -> []
  in


    (* Helper for shouldBox function *)
  (* TODO: find out Logic of refer to same rib, Implement & check ancestors *)
  let ancestor param body = 
    let reads = findReads param body in
    let rp = List.map (fun e -> match e with
                                  | Var'(VarBound(_, _, pos)) -> pos
                                  | _ -> -1) reads in
    let writes = findWrites param body in
    let wp = List.map (fun e -> match e with
                                  | Set'(Var'(VarBound(_, _, pos)), _) -> pos
                                  | _ -> -1) writes in
    let wpf = List.filter (fun w -> w <> -1) wp in
    let common = List.filter (fun w -> List.exists (fun r -> r = w) rp) wpf in
    common = []
  in

  (* Improved version of shouldBox *)
  (* TODO: Add check of acestors *)
  let shouldBox param body = findWrites param body <> [] && findReads param body <> [] 
  (* && ancestor param body *)
  in


  *****
  prev 11.12 from reader.ml 
    
    (* Sexpr vector '[' parens *)
    let vector_ = 
      let prefix = word "#[" in
      let sexprs = make_spaced _sexpr in
      let lst = caten prefix (star sexprs) in
      let vector = caten lst rparen_ in
      let parsed = pack vector (fun (((_), slist), _) -> slist) in parsed
    in

    let vectors = disj_list [vector; vector_; ] in
    let _vector = pack vectors (fun (s) -> Vector s) in



    ******
    14.12


       | Seq' (Set' (Var' var), Box' (var)) ->
          Seq' ([(Set' (Var' var), Box' var), Set' (Var' (VarParam (param, pos)), Box' (VarParam (param, pos)))])
       | Seq' ((Set' (Var' var), Box' var), exprs)->
          Seq' ([(Set' (Var' var), Box' var), Set' (Var' (VarParam (param, pos)), Box' (VarParam (param, pos)))] @ exprs)



             let addSet (param, pos) body =
     match body with
       (* Change due to "box with Seq" Q in Forum, only one case, to Add seq *)
       (* TODO: add support for multiple params in box, in same body (=> same Seq') *)
       | Seq' [Set' (Var' v, Box' b)] ->
          Seq' ([Set' (Var' (VarParam (param, pos)), Box' (VarParam (param, pos))); Set' (Var' v, Box' b);])
       | Seq' [Set' (Var' v, Box' b); rest] -> 
          Seq' (Set' (Var' (VarParam (param, pos)), Box' (VarParam (param, pos))); [Set' (Var' v, Box' b); rest])
       | _ -> Seq' [Set' (Var' (VarParam (param, pos)), Box' (VarParam (param, pos))); body]
   in

  *******
   WORKING : 

      (* Add set expr' in first Seq' of body we need to box *)
   let addSet (param, pos) body =
    (match body with
      | Seq' exprs -> 
        (match exprs with
          | [Set' (_, Box' _)] -> Seq' [Set' (Var' (VarParam (param, pos)), Box' (VarParam (param, pos))); body]
          | [Set' (_, Box' _); _] | [Set' (_, Box' _); _; _] | [Set' (_, Box' _); _; _; _] -> 
              Seq' ([Set' (Var' (VarParam (param, pos)), Box' (VarParam (param, pos)))] @ exprs)
          | _ -> Seq' [Set' (Var' (VarParam (param, pos)), Box' (VarParam (param, pos))); body])
      | _ -> Seq' [Set' (Var' (VarParam (param, pos)), Box' (VarParam (param, pos))); body])
  in




  24.12
  *****
          from expand-lst
          
              (* let rec expand_pair car currCar currCdr newLst = 
              (match currCdr with
                | Pair (f, s) -> [currCar] @ expand_pair car f s [] @ [car] @ newLst
                | _ -> expand_lst cdr ([currCar; currCdr; car] @ newLst))
              in
              expand_pair car currCar currCdr newLst *)


                          (* expand_lst cdr [currCar; currCdr; car] @ newLst *)



25.12, 22.44
*****


  (* [(Void, 0, "MAKE_VOID");
  (Sexpr(Nil), 1, "MAKE_NIL");
  (Sexpr(Bool false), 2, "MAKE_BOOL(0)");
  (Sexpr(Bool true), 4, "MAKE_BOOL(1)");
  (Sexpr(String "ab"), 6, "MAKE_LITERAL_STRING(\"ab\")");
  (Sexpr(Number(Int 1)), 17, "MAKE_LITERAL_INT(1)");
  (Sexpr(Number(Int 2)), 26, "MAKE_LITERAL_INT(2)");
  (Sexpr(Pair(Number(Int 2),
  Nil)), 35, "MAKE_LITERAL(consts+26, consts+1");
  (Sexpr(Pair(Number(Int 1),
  Pair(Number(Int 2)), Nil)), 52, "MAKE_LITERAL(consts+17, consts+35");
  (Sexpr(String "c"), 69, "MAKE_LITERAL_STRING(\"c\")");
  (Sexpr(Symbol "c"), 79, "MAKE_LITERAL_SYMBOL(consts+69)");
  (Sexpr(Symbol "ab"), 88, "MAKE_LITERAL_SYMBOL(consts+6)")] *)


Amir tests 25.12

scan_test "1";;
scan_test "1 1";;
scan_test "'(1)";;
scan_test "'(1 2 3 4)";;
scan_test "(foo 2)";;
scan_test "(+ 1 2)";;
scan_test "'a";;
scan_test "'(1 (2 3))";;
scan_test "'(1 .(2 3))";;
scan_test "#( #t )";;
scan_test "#( 37392 )";;
scan_test "#( 37392.39382 )";;
scan_test "#( #\\c 37392.39382 )";; 
dups_test "1";;
dups_test "1 1";; 
dups_test "'(1 (2 3))";; 
dups_test "#( #\\c 37392.39382 )";; 

expand_test "1";;
expand_test "1 1";; 
expand_test "'a";;
expand_test "'(1)";;
expand_test "#( #\\c 37392.39382 )";; 
expand_test "'(1 (2 3))";; 

dups2_test "1";;
dups2_test "1 1";; 
dups2_test "'a";;
dups2_test "'(1)";;
dups2_test "#( #\\c 37392.39382 )";; 
dups2_test "'(1 (2 3))";;
dups2_test "'((1 2) (2 3))";;
dups2_test "\"This is a string\"";;



25.12 removed funcs 

  let sexp_eq s1 s2 = (* s1 = Sexpr (String str1), s2 = Sexpr(String str2) *)
    match s1, s2 with
      | (Symbol sym), (String str) -> sym = str
      | (Number n1), (Number n2) -> n1 = n2
      | (Bool b1), (Bool b2) -> b1 = b2
      | s_1, s_2 -> s_1 = s_2;;

  (*  *)
  let rec orig_addr s tbl = 
    let filt = List.map (fun (_,(a, _)) -> a) (List.filter (fun (Sexpr sexpr, (_, _)) -> sexp_eq s sexpr) tbl) in
    if (List.length filt) = 0 then -1 else (List.nth filt 0);;


  val filter_const : sexpr list -> sexpr list


      let rec filter_const lst const = 
    match lst with
      | car :: cdr ->
          (match car with
            | Bool _ | Number _ | Nil | Char _ | String _ | Symbol _ | Pair _ | Vector _ -> 
              if List.mem car const then filter_const cdr const else filter_const cdr (const @ [car])
            | _ -> filter_const cdr const) (* TODO: fix warning *)
      | [] -> const;;

  let filter_const lst = filter_const lst [];;


  in cons_tbl

            (* let lst_const = List.map (fun elem -> cons_tbl [elem] tbl (addr + size_of elem)) vec in
          let merge = List.fold_right (fun l1 l2 -> l1 @ l2) lst_const (List.nth lst_const 0) in
          remove_dups merge *)



          in tests
          
let filt_test x = filter_const (expand_test x) ;;

          (* Filt cond test *)
let f1 = sexprs_eq (filt_test "'(1 (2 3))") (  [Number (Int 1); Number (Int 2); Number (Int 3); Nil;
                                                  Pair (Number (Int 3), Nil);
                                                  Pair (Number (Int 2), Pair (Number (Int 3), Nil));
                                                  Pair (Pair (Number (Int 2), Pair (Number (Int 3), Nil)), Nil);
                                                  Pair (Number (Int 1),
                                                  Pair (Pair (Number (Int 2), Pair (Number (Int 3), Nil)), Nil))]);;
let f2 = filt_test "(list \"ab\" '(1 2) 'c 'ab)";;





***
4.1
foo.scm 


;  1 2 #t 5 3.14 #\a '() "yo" #(1 2 3) 'cool '(1) '(1 2 3) '(9 . 9) '(3.14)
;  (if (if (if 1 2 3) (if 4 (if 5 (if 6 7 8) 9) 10) (if 11 (if 12 (if 13 14 15) 16) 17)) (if 18 (if 19 20 21) 22) 23)
; (or (or (or 1 2 3) (or 4 (or 5 (or 6 7 8) 9) 10) (or 11 (or 12 (or 13 14 15) 16) 17)) (or 18 (or 19 20 21) 22) 23)
;  (if (if (if 1 2 3) (if 4 (if 5 (or 6 7 8) 9) 10) (or 11 (or 12 (or 13 14 15) 16) 17)) (or 18 (or 19 20 21) 22) 23)
;  (if (or (if 1 2 3) (if 4 (if 5 (if 6 7 8) 9) 10) (if 11 (or 12 (or 13 14 15) 16) 17)) (if 18 (or 19 20 21) 22) 23)
;;  (boolean? 99)
;  1
;  (define x '(1 2))
;  (car '(1 2))
;   (cdr '(1 2))
;  x
;  (set! x 3)
;  (set! x '(1 2))
;  (car x)
;  (cdr x)
;  (define x '(1 2))
;   (set-car! x 0)
;   (set-cdr! x 0)
;   x ;; should print '(0 0)
; (cons 1 2) ;; should print (1 . 2)
; (cons 3 4) ;; should print (3 . 4)
;  (define goo (lambda(x)(lambda()1)))
; ((goo 9))
;; (define adder (lambda (x) (lambda (y) (+ x y))))
;  (define plus3 (adder 3))
;  (define g (lambda (x) x))
; ((lambda (x) (g (g x))) 1)
;  (plus3 9)
;; adder
;; ((adder 3) 9)
;  ((adder ((goo 9)))10)
; (define g (lambda(x)x))
; (define f (lambda(x)(+ x 1)))
; ((lambda (x) (f (g (g x))))5)



*****
5.1

 LambdaOpt prev

      raise X_not_yet_implemented
        
          (* let (curr_count, curr_env) = (!count, !env_count) in
          count := !count + 1;
          env_count := !env_count + 1;
          assemLambda vars body ^ (lcodeOpt body curr_count) *)


*****


ApplicTP case

prev

          let args = List.rev args in
          let len = List.length args in
          let rec applic_rec args =
            match args with
              | car :: cdr -> 
                (generate consts fvars car) ^ 
                "\tpush rax ;; applic case in generate func\n" ^ 
                applic_rec cdr
              | [] -> 
                "\tpush " ^ (string_of_int len) ^ "\n" ^
                (generate consts fvars op) ^
                "\tmov r9, [rax+TYPE_SIZE] ; closure's env\n" ^
                "\tpush r9 ; push env\n" ^
                "\tpush qword [rbp + 8] ; old ret addr\n" ^
                "\tmov r9, qword[rbp]\n" ^
                "\tSHIFT_FRAME " ^ (string_of_int (len + 5)) ^ "\n" ^
                "\tmov rbp, r9\n" ^
                "\tjmp [rax+TYPE_SIZE+WORD_SIZE] ; clousre's code\n"
          in
          "\tmov rax, 9999\n" ^
          "\tpush rax\n" ^
          (applic_rec args)



***
prev ApplicTP


                (* "\t" ^ "mov rsp, rbp ; restore old frame ptr register \n" ^
                "\t" ^ "mov r9, " ^ (string_of_int numArgs) ^ " ; loop idx (init to num args) \n" ^
                "\t" ^ "mov r10, rsp ; old frame ptr \n" ^
                "\t" ^ "mov r12, rbx ; curr env \n\n" ^
                "\t" ^ ".overwrite_frame" ^ (string_of_int currIdx) ^ ":\n" ^
                "\t\t" ^ "cmp r9, 0 ; cmp idx \n" ^ 
                "\t\t" ^ "jz .finish_overwrite_frame" ^ (string_of_int currIdx) ^ "\n" ^
                "\t\t" ^ "dec r9 ; dec loop idx \n" ^
                "\t\t" ^ "mov r11, qword[r10] ; old frame loc \n" ^
                "\t\t" ^ "mov r11, r12 ; old frame loc got curr env \n" ^
                "\t\t" ^ "add r10, WORD_SIZE ; inc old frame ptr \n" ^
                "\t\t" ^ "add r12, WORD_SIZE ; inc curr env \n" ^
                "\t\t" ^ "jmp .overwrite_frame" ^ (string_of_int currIdx) ^ " ; back to loop " ^ (string_of_int currIdx) ^ "\n\n" ^
                "\t" ^ ".finish_overwrite_frame" ^ (string_of_int currIdx) ^ ":\n" ^ *)



***
***
lcodeOpt

      (* Helper function for Lcode of LamdaOpt' *)
      let lcodeOpt body curr_count =
        "\t" ^ "Lcode" ^ (string_of_int curr_count) ^ ":\n" ^ (* TODO: Implement if necessary, or, remove if un necessary *)
        ";; adjust stack for opt args \n" ^ (* TODO: implement Lcode of LambdaOpt' (adjust stack for optional arguments) *)
        "\t" ^ "xor r15, r15 ; clean r15 (=magic) ? \n" ^ 
        "\t" ^ "push r15 ; push magic ? \n" ^ 
        "\t" ^ "push rbp\n" ^
        "\t" ^ "mov rbp, rsp\n" ^
        (generate consts fvars body) ^ 
        "\t" ^ "leave\n" ^
        "\t" ^ "ret\n" ^
        "\t" ^ "Lcont" ^ (string_of_int curr_count) ^ ":\n" in

****

lcode opt

      (* Helper function for Lcode of LamdaOpt' *)
      let lcodeOpt body curr_count =
        "\t" ^ "Lcode" ^ (string_of_int curr_count) ^ ":\n" ^ (* TODO: Implement if necessary, or, remove if un necessary *)
        ";; adjust stack for opt args \n" ^ (* TODO: implement Lcode of LambdaOpt' (adjust stack for optional arguments) *)
        "\t" ^ "xor r15, r15 ; clean r15 (=magic) ? \n" ^ 
        "\t" ^ "push r15 ; push magic ? \n" ^ 
        "\t" ^ "push rbp\n" ^
        "\t" ^ "mov rbp, rsp\n" ^
        (generate consts fvars body) ^ 
        "\t" ^ "leave\n" ^
        "\t" ^ "ret\n" ^
        "\t" ^ "Lcont" ^ (string_of_int curr_count) ^ ":\n" in


****

ApplicTP' back up
****

      | ApplicTP'(op, args) ->
          let revArgs = List.rev args in
          let numArgs = List.length args in
          (* Helper function, generate applic, in tail position *)
          let rec applicTP_gen args =
            match args with
              | car :: cdr -> 
                (generate consts fvars car) ^
                "\t" ^ "push rax" ^ " ; push arg \n" ^
                applicTP_gen cdr
              | [] -> 
                "\t" ^ "push " ^ (string_of_int numArgs) ^ "; push number args \n" ^
                "\t" ^ "; start parse op \n" ^
                (generate consts fvars op) ^
                "\t" ^ "; finish parse op \n" ^
                "\t" ^ "mov rbx, [rax + TYPE_SIZE] ; closure's env \n" ^
                "\t" ^ "push rbx ; push env (args) \n" ^
                (* Add code for ApplicTP' (Logic of code is from Lecture #5, pages 44-46) *)
                "\t" ^ "push qword[rbp + 8*1] ; push old ret addr \n" ^ 
                "\t" ^ "mov rsp, rbp ; restore old frame ptr register \n" ^
                (* Fix the stack *)
                "\t" ^ "SHIFT_FRAME " ^ (string_of_int (numArgs + 5)) ^ " ; shift frame, where frame size is " ^ (string_of_int (numArgs + 5)) ^ "\n" ^
                (generate consts fvars op) ^ (* parse op again, for closure code *)
                "\t" ^ "mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code \n" ^
                "\t" ^ "jmp rbx ; jmp to code (closure) \n" ^ (* change call to jmp *)
                "\t" ^ "add rsp, 8*1 ; pop env (args) \n" ^ 
                "\t" ^ "pop rbx ; pop number args \n" ^
                "\t" ^ "inc rbx ; add magic as param (for pop) \n" ^ 
                "\t" ^ "shl rbx, 3 ; rbx = rbx * 8 (calc size args) \n" ^
                "\t" ^ "add rsp, rbx ; pop args \n" 
          in
          "\n\t" ^ "mov rax, MAGIC ; ApplicTP \n" ^
          "\t" ^ "push rax ; push magic to stack \n" ^
          (applicTP_gen revArgs)

****
prev applic



      | Applic'(op, args) (* | ApplicTP'(op, args) *) -> 
          let args = List.rev args in
          let len = List.length args in
          (* Helper function, generate applic *)
          let rec applic_gen args =
            match args with
              | car :: cdr -> 
                (generate consts fvars car) ^
                "\t" ^ "push rax" ^ " ; push arg \n" ^ 
                applic_gen cdr
              | [] -> 
                "\t" ^ "push " ^ (string_of_int len) ^ " ; push number args \n" ^ 
                "\t" ^ "; start parse op \n" ^
                (generate consts fvars op) ^
                "\t" ^ "; finish parse op \n " ^
                "\t" ^ "mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx \n" ^
                "\t" ^ "push rbx ; push env (args) to stack (rsp stack pointer) \n" ^
                "\t" ^ "mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx \n" ^
                "\t" ^ "call rbx ; call code (of closure) \n" ^
                "\t" ^ "add rsp, 8*1 ; pop env (args) \n" ^ 
                "\t" ^ "pop rbx ; pop number args \n" ^
                "\t" ^ "inc rbx ; add magic as param (in counter) for pop \n" ^ 
                "\t" ^ "shl rbx, 3 ; rbx = rbx * 8 (calc size args) \n" ^
                "\t" ^ "add rsp, rbx ; pop args \n\n" 
          in
          "\n\t" ^ "mov rax, MAGIC ; Applic \n" ^
          "\t" ^ "push rax ; push magic to stack \n" ^
          (applic_gen args)


****

applic tp of amir last commit


         let args = List.rev args in
          let len = List.length args in
          let rec applic_rec args =
            match args with
                | car :: cdr -> 
                (generate consts fvars car) ^ 
                "\t" ^ "push rax \n" ^ 
                applic_rec cdr
              | [] -> 
                "\t" ^ "push " ^ (string_of_int len) ^ "\n" ^
                (generate consts fvars op) ^
                "\t" ^ "mov r9, [rax+TYPE_SIZE] ; closure's env\n" ^
                "\t" ^ "push r9 ; push env\n" ^
                "\t" ^ "push qword [rbp + 8] ; old ret addr\n" ^
                "\t" ^ "mov r9, qword[rbp]\n" ^
                "\t" ^ "SHIFT_FRAME " ^ (string_of_int (len + 4)) ^ "\n" ^
                "\t" ^ "mov rbp, r9 \n" ^
                "\t" ^ "jmp [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code \n"
          in 
          (* "\t" ^ "mov rax, MAGIC ; applic in tail position \n" ^ *)
          (* "\t" ^ "push rax \n" ^ *)
          (applic_rec args)

****

prev applic

(* "\t" ^ ";; update 6.1" ^ "\n" ^
      "\t" ^ "mov rdi, " ^ (string_of_int len) ^ " ; store num args in rdi \n" ^
      "\t" ^ "sub rdi, rsi ; rdi = num args - num params = length of opt list \n" ^
      
      "\t" ^ "add rsp, 8" ^ " ; got stack ptr \n" ^
      "\t" ^ "mov rcx, MAGIC ; default case, for push magic as arg, if | opt list | = 0, and the list should be empyu \n" ^
      "\n\t" ^ ".create_opt_list" ^ (string_of_int current) ^ ":\n" ^
      "\t\t" ^ "cmp rdi, 0 ; loop |opt list| times \n" ^
      "\t\t" ^ "je .done_create_opt_list" ^ (string_of_int current) ^ "\n" ^
      "\t\t" ^ "pop rbx" ^ " ; get the last arg \n" ^ 
      "\t\t" ^ "mov rdx, qword[rbx] ; get last arg \n" ^
      "\t\t" ^ "mov esi, SOB_NIL_ADDRESS ; init to SOB_NIL_ADDRESS, second element to make_pair \n" ^
      "\t\t" ^ "MAKE_PAIR(rcx, rdx, esi) ; rcx store ptr for new pair, rdx is curr arg \n" ^
      "\t\t" ^ "mov esi, rcx ; now esi is new pair (in next iteration, second element to make_pair) \n" ^
      "\t\t" ^ "dec rdi ; dec loop idx \n" ^
      "\t\t" ^ "jmp .create_opt_list" ^ (string_of_int current) ^ "\n" ^

      "\n\t" ^ ".done_create_opt_list" ^ (string_of_int current) ^ ":\n" ^
      "\t" ^ "push rcx ; push the list created \n" ^
      "\t" ^ "sub rsp, 8 ; get rsp back, to before create the opt list \n" ^
      "\t" ^ ";; now the opt list is pushed on stack, and ready, the rsp again point to the number of args (n) \n" ^ *)

            (* ^ "\tmov rsi, 0 ; clean rsi to next store of number of args \n" *)

****


;;;;; LIST OF CHANGES:

;;;;;; Applic-
;;;;; .1. const_tbl+1 as magic
;;;;; .2. mov r11, nArgs (no magic)

;;;;; LamnbdaOpt-
;;;;; .1. mov r13, nParams (no opt)
;;;;; .2. 


    ;;; Applic
    ;;; Change in #<applic_rec> procedure this 2 lines.
	mov rax, const_tbl + 1 ; Nil, as magic
    ;;;; mov r11, <nArgs>

	push rax
    mov rax, const_tbl + 4 ; mov rax, AddressInConstTable ;; #t, as param
	push rax
	push 1 ; parsing of operator below: ; num args


	lambdaOpt1:
	mov rsi, 0 ; store num of params in rsi 
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 0 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 0 ; 0 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode1)
		jmp Lcont1


	Lcode1:
	push rbp
	mov rbp , rsp
    
    ;;; Inject this code to #<lcodeOpt> procedure
    ;;; Closure body

    mov r13, 0 ; |Params| ;;;;; mov r13, <nParams>
    mov r11, 1 ; |Args|
    sub r11, r13 ; |Opt list|

    mov r12, 0 ; Idx Loop
    mov r9, const_tbl + 1 ; Nil element

    .create_opt_list:
        cmp r12, r11
        je .done_create_opt_list
        mov r8, PVAR(r12)
        inc r12
        MAKE_PAIR(rax, r8, r9) ;;; List of Opt args, into rax
        mov r9, rax
        jmp .create_opt_list
    
    .done_create_opt_list:
    
    ;;; Put list (rax) in last param location
    mov r10, rbp
    add r13, 0
    shl r13, 3 
    add r10, r13
    add r10, 8 * 4 
    mov [r10], rax

    ;;;; Original body of closure.
    ;;;; if want to take last param, it is in Location of last param.
    ;;;; In this case, it in the first (0) Param.

	mov rax, PVAR(0) ; mov rax, qword[rbp + 8 * (4 + 0)], pos (= minor) 
	
    leave
	ret

*****


lcode opt
*****



        (* "\t" ^ "mov r12, 0 ; Idx Loop\n" ^
        "\t" ^ "add r12, 1 \n " ^ *)
        (* "\t" ^ "add rcx, 1 \n" ^ *)


*****
apply

*****


    ; push r10 ;; checkkk 
    ; mov r8, r11 ;; list got cdr
    ; add r12, 1 ;; inc counter <nargs>
    ; cmp r11, r13
    ; je .push_elems
    ;; push r12 ;; push <nargs> 
    ; push 2 ;;; 3 args ;; 1,2, nil


  
    ; add rsp, 2 * 8 ;; 1 args * 8 , 8 is size of each param
    ; cmp r11, r13  ;;;;
    ; je .return
    ;;;; je .finish_push_elems ;;;; 
    ; jmp .push_elems ;;;;
    ;;;; jmp .return




    ; MALLOC r15, 8    ;; add to 0 each time
    ; mov qword[r15], 5 ;; init number 0 to push at first time
    ; mov rax, r15 ;; mov to rax for first time

*****

apply


apply:
    push rbp
    mov rbp, rsp

    mov r9, PVAR(0) ;; proc
    mov r8, PVAR(1) ;; pair

    mov r12, 0 ;; counter <nargs>, count from first arg
    mov r13, const_tbl + 1  ;; for cmp in loop

    .push_elems:

	CAR r10, r8 ;; r10 got car
    CDR r11, r8 ;; r11 got cdr

    push r10 ;; push car
    mov r8, r11 ;; old cdr is new list
    add r12, 1 ;; inc <nargs> counter

    cmp r11, r13
    jne .push_elems

    ;; reverse elems
    ;; this implemetation is work now without loop (basic case for 2 elems)
    ;; for more elems, we need to support first at more elems in apply
    ;; n = n - 2, at each iteration (at first, n = <nArgs> = r12)
    pop rax ;; first elem
    
    ;; get to next elem to pop (to swap)
    mov r8, r12 ;; n
    sub r8, 2 ;; n-2
    shl r8, 3 ;; (n-2)*8
    add rsp, r8 ;; add rsp, (n-2)*8 ;; this is the "offset" between 2 elems of curr swap.
    
    pop rbx ;; sec elem
    push rax ;; first step of swap 

    sub rsp, r8 ;; go to first elem loc
    push rbx ;; second step of swap


    push r12 ;; num args

    mov rax, r9 ;; proc ptr
    mov rbx, [rax+TYPE_SIZE] ;; env
	push rbx ;; push env
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ;; code
	call rbx ;; call code (code of closure)

    add rsp, 8 ;; add num args
    pop rbx ;; pop args count
    shl r12, 3 ;; 8 * <nargs>
    add rsp, r12 ;; add the size of args
  

.return:
    leave
    ret


*****

lambdaOpt

.........

    cmp r13, 0 ; Variadic case 
	jne .non_variadic ; 
	
    sub r12, 1 ; go to prev param 
	sub r14, 1 ; let us do one more loop 
	
    .non_variadic: 

    cmp r13, 2
    jl .one_arg
    add r12, 1 ;;; ? ;;;; 1
    add r14, 1 ;;; ? ;; 0

    .one_arg:

	.create_opt_list: 
		cmp r12, r14 ; new counter end of loop 
		je .done_create_opt_list 
		mov r8, PVAR(r12)
		dec r12
		MAKE_PAIR(rax, r8, r9) ;;; List of Opt args, into rax
		mov r9, rax

    ............
    
*****
;LambdaOpt

	;; Closure Body 

	mov r13, 3 ; |Params|

    mov r15, rcx ;; ADDED ;; <nArgs>
    add r15, -1 ;; ADDED ;; <nArgs> - 1

	; sub rcx, r13 ;; REMOVED 
	mov r12, rcx ; Counter for loop
    sub r12, r13 ; <nArgs> - <nParams> = |Opt list| = 2
	
    ; add r12, 0 ;; REMOVED

	mov r9, const_tbl + 1 ; Nil, for first pair
	mov r14, 0 ; Comparator for loop condition

    ;; TODO: check if this case is necessary
	; cmp r13, 0 ; <nParams> = 0, Variadic case
	; jne .non_variadic 
	; sub r12, 1 ;; COMMENTED
	; sub r14, 1 ;; COMMENTED

	.non_variadic: 
	cmp r13, 2 ; if |Params| < 2
	jl .create_opt_list ; jump ;; CHANGED
	add r12, 1 ; Counter for loop
 	add r14, 1 ; Comparator for loop condition

 	; .one_arg:  ;; REMOVED
	.create_opt_list: 
		cmp r12, r14 ; Loop condition
		je .done_create_opt_list
		mov r8, PVAR(r15) ;; CHANGED r15*
        add r15, -1 ;; ADDED (dec each iter)
		dec r12 ; Loop counter
		MAKE_PAIR(rax, r8, r9) ; Make List
		mov r9, rax ; Caten to next List
		jmp .create_opt_list 

	.done_create_opt_list: 
	mov rax, r9 ; By default Nil

	mov r10, rbp ; Put list in Opt loc
	; add r13, 0 ;; REMOVED
	shl r13, 3 ; <nParams> * 8
	add r10, r13 ; rbp + <sizeParams>
	add r10, 8 * 4 
	mov [r10], rax ; Put list

	; Original Closure Body

*****
lamdda  simple



	Lcode1:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 
	;; Closure Body 

    mov r15, rcx ; <nArgs> 
	add r15, -1 ; <nArgs> - 1 

    ; mov r12, rcx ; Counter for loop :: 2 ;; Comment Out
	; sub r12, r13 ; <nArgs> - <nParams> = |Opt list| = 2 :: 2 ;; Comment Out
    ; mov r14, 0 ; Comparator for loop condition ;; ;; Comment Out


	mov r9, const_tbl + 1 ; Nil, for first pair 



	;; TODO: check if this case is necessary 
	; cmp r13, 0 ; <nParams> = 0, Variadic case ;; Comment Out
    ; jne .non_variadic ;; Comment Out
	; sub r12, 1 ;; Comment Out
	; sub r14, 1 ;; Comment Out
	; .non_variadic: ;; Comment Out

	; cmp r13, 2 ; if |Params| < 2 ;; Comment Out
	; jl .create_opt_list ; jump ;; Comment Out
	; add r12, 1 ; Counter for loop ;; Comment Out
	; add r14, 1 ; Comparator for loop condition ;; Comment Out

	.create_opt_list: 
	
    cmp r12, r14 ;; Comment Out
	je .done_create_opt_list ;; Comment Out

	mov r8, PVAR(r15) ; Index Of Curr Param
    

    cmp r8, const_tbl+1 ;; C
    je .done_create_opt_list ;; C

	add r15, -1 ; dec each iter

	; dec r12 ; Loop counter ;; Comment Out

	MAKE_PAIR(rax, r8, r9) ; Make List 
	mov r9, rax ; Caten to next List 
	jmp .create_opt_list 
	
    .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
 	mov r10, rbp ; Put list in Opt loc 
    
    mov r13, 0 ; |Params| ;; MOOVED

	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 
	;; Original Closure Body 
	mov rax, PVAR(0) ; VarParam, mov rax, qword[rbp + 8 * (4 + minor)], pos (= minor) 
	leave ; done parsing lambdaOpt body above 
	ret


*****

        (* "\t" ^ "mov r15, rcx ; <nArgs> \n" ^ *)
        "\t" ^ "mov r15, " ^ (string_of_int len) ^ " ; Start From Last Param \n" ^
        (* "\t" ^ "add r15, -1 ; <nArgs> - 1 \n" ^ *)
        "\t" ^ "mov r9, const_tbl + 1 ; Nil, for first pair \n\n" ^
        "\t" ^ ".create_opt_list: \n " ^
        "\t" ^ "mov r8, PVAR(r15) ; Index Of Curr Param \n " ^
        "\t" ^ "cmp r8, const_tbl+1 ;; If Magic, is Last Param \n" ^
        "\t" ^ "je .done_create_opt_list \n" ^
        "\t" ^ "add r15, 1 ; Dec each Iter \n" ^ (* Changed from -1 (start from first to last) *)
        "\t" ^ "MAKE_PAIR(rax, r8, r9) ; Make List \n" ^ (* List will be now Reversed : | *)
        "\t" ^ "mov r9, rax ; Caten to next List \n" ^
        "\t" ^ "jmp .create_opt_list \n\n" ^    *)
        

        *************



    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov r14, 0 ;; C, <nParams>
	mov r15, 0 ; Start From Last Param 
	mov r9, const_tbl + 1 ; Nil, for first pair 

	.get_opt_args: ;; C
 	mov r8, PVAR(r15) ; Index Of Curr Param  ;; C
	add r15, 1 ; Dec each Iter 
    cmp r8, const_tbl+1 ;; If Magic, is Last Param ;; C
	je .create_opt_list ;; C 
	; MAKE_PAIR(rax, r8, r9) ; Make List ;; C
	; mov r9, rax ; Caten to next List ;; C
	jmp .get_opt_args ;; C

	; .done_create_opt_list: ;; C

    mov r15, 1 ;;

    .create_opt_list: 
 	mov r8, PVAR(r15) ; Index Of Curr Param  ;; C
 	cmp r15, r14 ;; If Magic, is Last Param 
	je .done_create_opt_list ;; C
	add r15, -1 ; Dec each Iter ;; C
	MAKE_PAIR(rax, r8, r9) ; Make List ;; C
	mov r9, rax ; Caten to next List ;; C
	jmp .create_opt_list 

    .done_create_opt_list:
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



******

******

Helper compile-

ocaml compiler.ml compilerTest.scm > compilerTest.s
nasm -felf64 -o compilerTest.o compilerTest.s
gcc -m64 -static -o compilerTest compilerTest.o


***
Helper debug-
          
set script-extension soft
set disassembly-flavor intel
set tui border-kind acs
layout asm
tui enable
tui reg general


display registers while debbuging-
x/nxg register/address
x/12xg $rsp


***
before ret instruction-


wit shift_frame-
rsp before ret is-
0x0000000000401268 in Lcode0 ()
(gdb) x $rsp
0x7fffffffdb50: 0x00000000006cb5b7
(gdb) p $rsp
$17 = (void *) 0x7fffffffdb50


without shift_frame-
rsp before ret is-
(gdb) x $rsp
0x7fffffffdb50: 0x0040121f
(gdb) p $rsp
$1 = (void *) 0x7fffffffdb50
