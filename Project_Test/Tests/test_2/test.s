
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
malloc_pointer:
    resq 1

section .data
const_tbl:
MAKE_VOID ; my address is 0
MAKE_NIL ; my address is 1
MAKE_BOOL(0) ; my address is 2
MAKE_BOOL(1) ; my address is 4
MAKE_LITERAL_CHAR(0) ; my address is 6
MAKE_LITERAL_STRING 116, 104, 105, 115, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 97, 110, 32, 101, 114, 114, 111, 114, 44, 32, 98, 117, 116, 32, 121, 111, 117, 32, 100, 111, 110, 39, 116, 32, 115, 117, 112, 112, 111, 114, 116, 32, 101, 120, 99, 101, 112, 116, 105, 111, 110, 115 ; my address is 8
MAKE_LITERAL_INT(0) ; my address is 74
MAKE_LITERAL_INT(1) ; my address is 83
MAKE_LITERAL_STRING 119, 104, 97, 116, 101, 118, 101, 114 ; my address is 92
MAKE_LITERAL_SYMBOL(const_tbl + 92) ; my address is 109
MAKE_LITERAL_FLOAT(5.5) ; my address is 118

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl + 0
%define SOB_NIL_ADDRESS const_tbl + 1
%define SOB_FALSE_ADDRESS const_tbl + 2
%define SOB_TRUE_ADDRESS const_tbl + 4

fvar_tbl:
dq T_UNDEFINED ; i'm boolean?, my address is 0
dq T_UNDEFINED ; i'm float?, my address is 1
dq T_UNDEFINED ; i'm integer?, my address is 2
dq T_UNDEFINED ; i'm pair?, my address is 3
dq T_UNDEFINED ; i'm null?, my address is 4
dq T_UNDEFINED ; i'm char?, my address is 5
dq T_UNDEFINED ; i'm vector?, my address is 6
dq T_UNDEFINED ; i'm string?, my address is 7
dq T_UNDEFINED ; i'm procedure?, my address is 8
dq T_UNDEFINED ; i'm symbol?, my address is 9
dq T_UNDEFINED ; i'm string-length, my address is 10
dq T_UNDEFINED ; i'm string-ref, my address is 11
dq T_UNDEFINED ; i'm string-set!, my address is 12
dq T_UNDEFINED ; i'm make-string, my address is 13
dq T_UNDEFINED ; i'm vector-length, my address is 14
dq T_UNDEFINED ; i'm vector-ref, my address is 15
dq T_UNDEFINED ; i'm vector-set!, my address is 16
dq T_UNDEFINED ; i'm make-vector, my address is 17
dq T_UNDEFINED ; i'm symbol->string, my address is 18
dq T_UNDEFINED ; i'm char->integer, my address is 19
dq T_UNDEFINED ; i'm integer->char, my address is 20
dq T_UNDEFINED ; i'm eq?, my address is 21
dq T_UNDEFINED ; i'm +, my address is 22
dq T_UNDEFINED ; i'm *, my address is 23
dq T_UNDEFINED ; i'm -, my address is 24
dq T_UNDEFINED ; i'm /, my address is 25
dq T_UNDEFINED ; i'm <, my address is 26
dq T_UNDEFINED ; i'm =, my address is 27
dq T_UNDEFINED ; i'm car, my address is 28
dq T_UNDEFINED ; i'm cdr, my address is 29
dq T_UNDEFINED ; i'm set-car!, my address is 30
dq T_UNDEFINED ; i'm set-cdr!, my address is 31
dq T_UNDEFINED ; i'm cons, my address is 32
dq T_UNDEFINED ; i'm apply, my address is 33
dq T_UNDEFINED ; i'm equal?, my address is 34
dq T_UNDEFINED ; i'm >, my address is 35
dq T_UNDEFINED ; i'm vector, my address is 36
dq T_UNDEFINED ; i'm vector->list, my address is 37
dq T_UNDEFINED ; i'm list->vector, my address is 38
dq T_UNDEFINED ; i'm map, my address is 39
dq T_UNDEFINED ; i'm number?, my address is 40
dq T_UNDEFINED ; i'm not, my address is 41
dq T_UNDEFINED ; i'm length, my address is 42
dq T_UNDEFINED ; i'm list?, my address is 43
dq T_UNDEFINED ; i'm list, my address is 44
dq T_UNDEFINED ; i'm zero?, my address is 45
dq T_UNDEFINED ; i'm append, my address is 46

global main
section .text
main:
    push rbp 
    mov rbp, rsp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp

    jmp code_fragment

code_fragment:
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [fvar_tbl + 0 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [fvar_tbl + 1 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [fvar_tbl + 2 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [fvar_tbl + 3 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [fvar_tbl + 4 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [fvar_tbl + 5 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_vector)
    mov [fvar_tbl + 6 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [fvar_tbl + 7 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [fvar_tbl + 8 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [fvar_tbl + 9 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [fvar_tbl + 10 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [fvar_tbl + 11 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [fvar_tbl + 12 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [fvar_tbl + 13 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_length)
    mov [fvar_tbl + 14 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_ref)
    mov [fvar_tbl + 15 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_set)
    mov [fvar_tbl + 16 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_vector)
    mov [fvar_tbl + 17 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [fvar_tbl + 18 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [fvar_tbl + 19 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [fvar_tbl + 20 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [fvar_tbl + 21 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [fvar_tbl + 22 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [fvar_tbl + 23 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [fvar_tbl + 24 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [fvar_tbl + 25 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [fvar_tbl + 26 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [fvar_tbl + 27 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
    mov [fvar_tbl + 28 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
    mov [fvar_tbl + 29 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
    mov [fvar_tbl + 30 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
    mov [fvar_tbl + 31 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
    mov [fvar_tbl + 32 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
    mov [fvar_tbl + 33 * WORD_SIZE], rax
    
user_code:

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+32*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 4 ; <nArgs> 
	push 4 ; parse <op> below: 

lambdaSimple1:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*0 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 0 ; 0 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode1)
	jmp Lcont1

Lcode1:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 


lambdaOpt2:
	mov rsi, 0 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*4 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode2)
	jmp Lcont2

Lcode2:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 0 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rax, const_tbl+1 ; Const 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 

lambdaSimple4:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode4)
	jmp Lcont4

Lcode4:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS


lambdaSimple5:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 3 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode5)
	jmp Lcont5

Lcode5:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse6
	mov rax, PVAR(0) ; VarParam 
	jmp LexitIf6

Lelse6:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 

lambdaSimple8:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 4 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode8)
	jmp Lcont8

Lcode8:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS


lambdaSimple9:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 5 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode9)
	jmp Lcont9

Lcode9:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(4) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse10
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(4) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(4) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(2)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf10

Lelse10:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(4) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(4) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(4) 
	mov rax, BVAR(3)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf10:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont9:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS

	mov rax, PVAR(0) ; BoxGet, VarParam 
	mov rax, qword [rax]
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont8:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 



LexitIf6:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont5:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS

	mov rax, PVAR(0) ; BoxGet, VarParam 
	mov rax, qword [rax]
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont4:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaOpt body above 

	ret 

Lcont2:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont1:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+46*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+27*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 

lambdaSimple19:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode19)
	jmp Lcont19

Lcode19:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

lambdaSimple20:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode20)
	jmp Lcont20

Lcode20:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+74 ; Const 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont20:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont19:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+45*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void



lambdaOpt21:
	mov rsi, 0 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*4 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode21)
	jmp Lcont21

Lcode21:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 0 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 
	mov rax, PVAR(0) ; VarParam 
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont21:
	mov qword [fvar_tbl+44*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+3*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 3 ; <nArgs> 
	push 3 ; parse <op> below: 

lambdaSimple23:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode23)
	jmp Lcont23

Lcode23:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

lambdaSimple24:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode24)
	jmp Lcont24

Lcode24:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr25


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse27
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 
	mov rax, qword [fvar_tbl+43*WORD_SIZE] ; VarFree 
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf27

Lelse27:
	mov rax, const_tbl+2 ; Const 


LexitIf27:
	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr25

	LexitOr25:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont24:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont23:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+43*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+22*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+3*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 4 ; <nArgs> 
	push 4 ; parse <op> below: 

lambdaSimple31:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode31)
	jmp Lcont31

Lcode31:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

lambdaSimple32:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode32)
	jmp Lcont32

Lcode32:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 

lambdaSimple33:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode33)
	jmp Lcont33

Lcode33:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(1) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(1), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS

	mov rax, const_tbl+74 ; Const 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS


lambdaSimple34:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 3 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode34)
	jmp Lcont34

Lcode34:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse35
	mov rax, PVAR(1) ; VarParam 
	jmp LexitIf35

Lelse35:

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse36
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rax, const_tbl+83 ; Const 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(1)
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf36

Lelse36:
	mov rax, const_tbl+8 ; Const 


LexitIf36:


LexitIf35:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont34:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(1)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS

	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+74 ; Const 
	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, PVAR(1) ; BoxGet, VarParam 
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont33:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont32:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont31:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+42*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+42*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+27*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+13*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 5 ; <nArgs> 
	push 5 ; parse <op> below: 

lambdaSimple42:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*4 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 4 ; 4 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode42)
	jmp Lcont42

Lcode42:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 


lambdaOpt43:
	mov rsi, 1 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*5 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode43)
	jmp Lcont43

Lcode43:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 1 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse44
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+6 ; Const 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf44

Lelse44:

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, const_tbl+83 ; Const 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse45
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf45

Lelse45:
	mov rax, const_tbl+8 ; Const 


LexitIf45:


LexitIf44:
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont43:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont42:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+13*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+17*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+42*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 4 ; <nArgs> 
	push 4 ; parse <op> below: 

lambdaSimple51:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode51)
	jmp Lcont51

Lcode51:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 


lambdaOpt52:
	mov rsi, 1 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*5 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode52)
	jmp Lcont52

Lcode52:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 1 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse53
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+74 ; Const 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf53

Lelse53:

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, const_tbl+83 ; Const 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [fvar_tbl+27*WORD_SIZE] ; VarFree 
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse54
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf54

Lelse54:
	mov rax, const_tbl+8 ; Const 


LexitIf54:


LexitIf53:
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont52:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont51:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+17*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+21*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 

lambdaSimple60:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode60)
	jmp Lcont60

Lcode60:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

lambdaSimple61:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode61)
	jmp Lcont61

Lcode61:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+4 ; Const 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse62
	mov rax, const_tbl+2 ; Const 
	jmp LexitIf62

Lelse62:
	mov rax, const_tbl+4 ; Const 


LexitIf62:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont61:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont60:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+41*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+2*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+1*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 

lambdaSimple65:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode65)
	jmp Lcont65

Lcode65:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

lambdaSimple66:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode66)
	jmp Lcont66

Lcode66:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr67

	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr67

	LexitOr67:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont66:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont65:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+40*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+33*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+32*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 5 ; <nArgs> 
	push 5 ; parse <op> below: 

lambdaSimple70:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode70)
	jmp Lcont70

Lcode70:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 


lambdaOpt71:
	mov rsi, 2 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*5 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode71)
	jmp Lcont71

Lcode71:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 2 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(2) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse72
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple84:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode84)
	jmp Lcont84

Lcode84:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple85:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 3 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode85)
	jmp Lcont85

Lcode85:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS


lambdaSimple86:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 4 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode86)
	jmp Lcont86

Lcode86:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(3) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse87
	mov rax, const_tbl+1 ; Const 
	jmp LexitIf87

Lelse87:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(3) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(3) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(3) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf87:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont86:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS

	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 
	mov rax, PVAR(0) ; BoxGet, VarParam 
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont85:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont84:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf72

Lelse72:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(2) ; VarParam 
	push rax 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 

lambdaSimple73:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode73)
	jmp Lcont73

Lcode73:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple74:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 3 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode74)
	jmp Lcont74

Lcode74:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS


lambdaSimple75:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 4 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode75)
	jmp Lcont75

Lcode75:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(3) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse76
	mov rax, const_tbl+1 ; Const 
	jmp LexitIf76

Lelse76:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(3) 
	mov rax, BVAR(4)  
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [fvar_tbl+39*WORD_SIZE] ; VarFree 
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(3) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(3) 
	mov rax, BVAR(3)  
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [fvar_tbl+39*WORD_SIZE] ; VarFree 
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(3) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(0)  
	push rax 
	mov rcx, 3 ; <nArgs> 
	push 3 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(3) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(3) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf76:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont75:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS

	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(1)  
	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, PVAR(0) ; BoxGet, VarParam 
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont74:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont73:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf72:
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont71:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont70:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+39*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+22*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+42*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+17*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+3*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 7 ; <nArgs> 
	push 7 ; parse <op> below: 

lambdaSimple95:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*5 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 5 ; 5 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode95)
	jmp Lcont95

Lcode95:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

lambdaSimple96:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode96)
	jmp Lcont96

Lcode96:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple97:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode97)
	jmp Lcont97

Lcode97:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS


lambdaSimple98:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 3 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode98)
	jmp Lcont98

Lcode98:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse99
	mov rax, PVAR(1) ; VarParam 
	jmp LexitIf99

Lelse99:

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse100
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(2) ; VarParam 
	push rax 
	mov rax, const_tbl+83 ; Const 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(6)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, PVAR(2) ; VarParam 
	push rax 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 3 ; <nArgs> 
	push 3 ; parse <op> below: 
	mov rax, qword [fvar_tbl+16*WORD_SIZE] ; VarFree 
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 


	mov rax, PVAR(1) ; VarParam 
	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 3 ; <nArgs> 
	push 3 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 8
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf100

Lelse100:
	mov rax, const_tbl+8 ; Const 


LexitIf100:


LexitIf99:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont98:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS

	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+74 ; Const 
	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(5)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	push rax 
	mov rcx, 3 ; <nArgs> 
	push 3 ; parsing of operator below: 
	mov rax, PVAR(0) ; BoxGet, VarParam 
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 8
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont97:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont96:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont95:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+38*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+24*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+14*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+32*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+15*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+26*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 5 ; <nArgs> 
	push 5 ; parse <op> below: 

lambdaSimple110:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode110)
	jmp Lcont110

Lcode110:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

lambdaSimple111:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode111)
	jmp Lcont111

Lcode111:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple112:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode112)
	jmp Lcont112

Lcode112:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS


lambdaSimple113:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 3 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode113)
	jmp Lcont113

Lcode113:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+74 ; Const 
	push rax 
	mov rax, PVAR(2) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse114
	mov rax, PVAR(1) ; VarParam 
	jmp LexitIf114

Lelse114:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+83 ; Const 
	push rax 
	mov rax, PVAR(2) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(2) ; VarParam 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 3 ; <nArgs> 
	push 3 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 8
	mov rbp, r15 
	jmp r10 ; code 



LexitIf114:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont113:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS

	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+83 ; Const 
	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, const_tbl+1 ; Const 
	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	push rax 
	mov rcx, 3 ; <nArgs> 
	push 3 ; parsing of operator below: 
	mov rax, PVAR(0) ; BoxGet, VarParam 
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 8
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont112:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont111:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont110:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+37*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+38*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 

lambdaSimple122:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode122)
	jmp Lcont122

Lcode122:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 


lambdaOpt123:
	mov rsi, 0 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*7 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode123)
	jmp Lcont123

Lcode123:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 0 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaOpt body above 

	ret 

Lcont123:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont122:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+36*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+33*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+22*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 5 ; <nArgs> 
	push 5 ; parse <op> below: 

lambdaSimple125:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode125)
	jmp Lcont125

Lcode125:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple126:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode126)
	jmp Lcont126

Lcode126:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS



lambdaOpt127:
	mov rsi, 0 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*7 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode127)
	jmp Lcont127

Lcode127:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 0 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse128
	mov rax, const_tbl+74 ; Const 
	jmp LexitIf128

Lelse128:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf128:
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont127:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS

	mov rax, PVAR(0) ; BoxGet, VarParam 
	mov rax, qword [rax]
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont126:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont125:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+22*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+33*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+23*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 5 ; <nArgs> 
	push 5 ; parse <op> below: 

lambdaSimple134:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode134)
	jmp Lcont134

Lcode134:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple135:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode135)
	jmp Lcont135

Lcode135:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS



lambdaOpt136:
	mov rsi, 0 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*7 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode136)
	jmp Lcont136

Lcode136:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 0 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse137
	mov rax, const_tbl+83 ; Const 
	jmp LexitIf137

Lelse137:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf137:
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont136:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS

	mov rax, PVAR(0) ; BoxGet, VarParam 
	mov rax, qword [rax]
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont135:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont134:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+23*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+42*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+33*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+22*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+24*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 7 ; <nArgs> 
	push 7 ; parse <op> below: 

lambdaSimple143:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode143)
	jmp Lcont143

Lcode143:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple144:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode144)
	jmp Lcont144

Lcode144:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS



lambdaOpt145:
	mov rsi, 0 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*7 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode145)
	jmp Lcont145

Lcode145:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 0 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse146
	mov rax, const_tbl+74 ; Const 
	jmp LexitIf146

Lelse146:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(6)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf146:
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont145:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS



lambdaOpt151:
	mov rsi, 0 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*7 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode151)
	jmp Lcont151

Lcode151:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 0 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse152
	mov rax, const_tbl+8 ; Const 
	jmp LexitIf152

Lelse152:

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+83 ; Const 
	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(5)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [fvar_tbl+27*WORD_SIZE] ; VarFree 
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse153
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, const_tbl+74 ; Const 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf153

Lelse153:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(6)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(2)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf153:


LexitIf152:
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont151:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont144:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont143:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+24*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+42*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+33*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+23*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+25*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 7 ; <nArgs> 
	push 7 ; parse <op> below: 

lambdaSimple162:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode162)
	jmp Lcont162

Lcode162:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 


lambdaOpt163:
	mov rsi, 0 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*7 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode163)
	jmp Lcont163

Lcode163:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 0 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse164
	mov rax, const_tbl+8 ; Const 
	jmp LexitIf164

Lelse164:

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+83 ; Const 
	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(5)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [fvar_tbl+27*WORD_SIZE] ; VarFree 
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse165
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, const_tbl+83 ; Const 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf165

Lelse165:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(6)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(2)  
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(1)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf165:


LexitIf164:
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont163:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont162:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+25*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+27*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 4 ; <nArgs> 
	push 4 ; parse <op> below: 

lambdaSimple174:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode174)
	jmp Lcont174

Lcode174:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple175:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode175)
	jmp Lcont175

Lcode175:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS


lambdaSimple176:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode176)
	jmp Lcont176

Lcode176:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse177
	mov rax, const_tbl+4 ; Const 
	jmp LexitIf177

Lelse177:

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse178
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf178

Lelse178:
	mov rax, const_tbl+2 ; Const 


LexitIf178:


LexitIf177:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont176:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS



lambdaOpt184:
	mov rsi, 0 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*7 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode184)
	jmp Lcont184

Lcode184:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 0 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse185
	mov rax, const_tbl+8 ; Const 
	jmp LexitIf185

Lelse185:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf185:
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont184:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont175:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont174:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+27*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+26*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 4 ; <nArgs> 
	push 4 ; parse <op> below: 

lambdaSimple190:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode190)
	jmp Lcont190

Lcode190:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple191:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode191)
	jmp Lcont191

Lcode191:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS


lambdaSimple192:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode192)
	jmp Lcont192

Lcode192:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse193
	mov rax, const_tbl+4 ; Const 
	jmp LexitIf193

Lelse193:

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse194
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf194

Lelse194:
	mov rax, const_tbl+2 ; Const 


LexitIf194:


LexitIf193:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont192:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS



lambdaOpt200:
	mov rsi, 0 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*7 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode200)
	jmp Lcont200

Lcode200:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 0 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse201
	mov rax, const_tbl+8 ; Const 
	jmp LexitIf201

Lelse201:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf201:
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont200:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont191:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont190:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+26*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+41*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+27*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+26*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+4*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 6 ; <nArgs> 
	push 6 ; parse <op> below: 

lambdaSimple206:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode206)
	jmp Lcont206

Lcode206:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple207:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode207)
	jmp Lcont207

Lcode207:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS


lambdaSimple208:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode208)
	jmp Lcont208

Lcode208:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse209
	mov rax, const_tbl+4 ; Const 
	jmp LexitIf209

Lelse209:

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr214


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr214

	LexitOr214:
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse210
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(5)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf210

Lelse210:
	mov rax, const_tbl+2 ; Const 


LexitIf210:


LexitIf209:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont208:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS



lambdaOpt220:
	mov rsi, 0 ; Store <nParams> in rsi 
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env|
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i
	mov r15, rbp ; r15 = rbp
	add r15, 32 ; r15 = address of first arg
	MALLOC r14, 8*7 ; allocate ExtEnv[0]
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments
	je .done_copy_params
	mov r9, [r15] ; r9 = Param(i)
	mov [r14], r9 ; ExtEnv [0][i] = r9
	add r14, 8
	add r15, 8
	inc r12
	jmp .copy_params 

.done_copy_params:
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode220)
	jmp Lcont220

Lcode220:
	push rbp
	mov rbp , rsp ; parse of lambdaOpt body below: 


	; Closure Body 
	mov r13, 0 ; Start From Last Param 
	mov r15, r13 ; Save last Param Idx 
	mov r9, const_tbl+1 ; Nil, for first pair 

.get_opt_args: 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	cmp r8, 6666 ; If Magic, is Last Param 
	je .create_opt_list 
	add r15, 1 ; Add each Iter, till reach Idx Last Arg in Opt List 
	jmp .get_opt_args 

.create_opt_list: 
	add r15, -1 ; Dec each Iter 
	mov r8, PVAR(r15) ; Index Of Curr Param  
	MAKE_PAIR(rax, r8, r9) ; Make List 
	cmp r15, r13 ; Go BackWard, till Last Param of Regular Params 
	jl .done_create_opt_list 
	mov r9, rax ; Caten to next List 
 	jmp .create_opt_list 
	cmp r15, r13 
	jne .create_opt_list 

 .done_create_opt_list: 
	mov rax, r9 ; By default Nil 
	mov r10, rbp ; Put list in Opt loc 
	shl r13, 3 ; <nParams> * 8 
	add r10, r13 ; rbp + <sizeParams> 
	add r10, 8 * 4  
	mov [r10], rax ; Put list 

	; Original Closure Body 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse221
	mov rax, const_tbl+8 ; Const 
	jmp LexitIf221

Lelse221:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(5)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(4)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 



LexitIf221:
	leave ; done parsing lambdaOpt body above 

	ret 

Lcont220:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont207:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont206:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+35*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [fvar_tbl+24*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+19*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+29*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+28*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+21*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+6*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+7*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+5*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+3*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+1*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+2*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+14*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+15*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+11*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+10*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+41*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+27*WORD_SIZE] ; VarFree 
	push rax 
	mov rax, qword [fvar_tbl+26*WORD_SIZE] ; VarFree 
	push rax 
	mov rcx, 18 ; <nArgs> 
	push 18 ; parse <op> below: 

lambdaSimple226:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 0 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*7 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 7 ; 7 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode226)
	jmp Lcont226

Lcode226:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

lambdaSimple268:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*18 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 18 ; 18 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode268)
	jmp Lcont268

Lcode268:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+109 ; Const 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple269:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*18 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 18 ; 18 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode269)
	jmp Lcont269

Lcode269:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 
	mov rax, PVAR(0) ; Box, VarParam 
	MALLOC rbx, 8 
	mov [rbx], rax 
	mov rax, rbx 
	mov qword PVAR(0), rax ; VarParam, Set 
	mov rax, SOB_VOID_ADDRESS


lambdaSimple270:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 3 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*18 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 18 ; 18 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode270)
	jmp Lcont270

Lcode270:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+74 ; Const 
	push rax 
	mov rax, PVAR(3) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse271
	mov rax, const_tbl+4 ; Const 
	jmp LexitIf271

Lelse271:

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(3) ; VarParam 
	push rax 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, PVAR(2) ; VarParam 
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(3) ; VarParam 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, PVAR(2) ; VarParam 
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [fvar_tbl+34*WORD_SIZE] ; VarFree 
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse272
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+83 ; Const 
	push rax 
	mov rax, PVAR(3) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(2) 
	mov rax, BVAR(17)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, PVAR(2) ; VarParam 
	push rax 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 4 ; <nArgs> 
	push 4 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; BoxGet, VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 9
	mov rbp, r15 
	jmp r10 ; code 

	jmp LexitIf272

Lelse272:
	mov rax, const_tbl+2 ; Const 


LexitIf272:


LexitIf271:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont270:
	push rax ; BoxSet, VarParam 
	mov rax, PVAR(0)
	pop qword [rax]
	mov rax, SOB_VOID_ADDRESS


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(1)  
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(2)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse278
	mov rax, const_tbl+2 ; Const 
	jmp LexitIf278

Lelse278:
	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, const_tbl+83 ; Const 
	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(3)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(17)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(2)  
	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(1)  
	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	push rax 
	mov rcx, 4 ; <nArgs> 
	push 4 ; parsing of operator below: 
	mov rax, PVAR(0) ; BoxGet, VarParam 
	mov rax, qword [rax]
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 9
	mov rbp, r15 
	jmp r10 ; code 



LexitIf278:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont269:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont268:
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parsing of operator below: 

lambdaSimple227:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 1 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*18 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 18 ; 18 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode227)
	jmp Lcont227

Lcode227:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

lambdaSimple228:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address 
	mov r12, 0 ; i 
	mov r13, 1 ; j 
	mov r15, qword[rbp + 16] ; lexical env 

.copy_env:
	cmp r12, 2 ; |env| 
	je .done_copy_env
	mov r14, qword[r15 + 8 * r12] ; r14 = Env[i] 
	mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14 
	inc r12 ; inc counter of loop 
	inc r13 ; inc counter of loop 
	jmp .copy_env ; back to loop 

.done_copy_env:
	mov r12, 0 ; i 
	mov r15, rbp 
	add r15, 32 ; r15 got Addrs of first arg 
	MALLOC r14, 8*18 ; allocate ExtEnv[0] 
	mov r11, r14 ; copy of ExtEnv[0] 

.copy_params:
	cmp r12, 18 ; 18 arguments 
	je .done_copy_params 
	mov r9, [r15] ; r9 = Param(i) 
	mov [r14], r9 ; ExtEnv [0][i] = r9 
	add r14, 8 
	add r15, 8 
	inc r12 
	jmp .copy_params 

.done_copy_params: 
	mov [r10], r11
	MAKE_CLOSURE(rax, r10, Lcode228)
	jmp Lcont228

Lcode228:
	push rbp 
	mov rbp, rsp ; parse lambdaSimple body below: 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(7)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse230

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(7)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse231

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	jmp LexitIf231

Lelse231:
	mov rax, const_tbl+2 ; Const 


LexitIf231:
	jmp LexitIf230

Lelse230:
	mov rax, const_tbl+2 ; Const 


LexitIf230:
	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr229


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(8)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse235

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(8)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse236

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	jmp LexitIf236

Lelse236:
	mov rax, const_tbl+2 ; Const 


LexitIf236:
	jmp LexitIf235

Lelse235:
	mov rax, const_tbl+2 ; Const 


LexitIf235:
	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr229


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(9)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse240

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(9)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse241

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(14)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(14)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [fvar_tbl+34*WORD_SIZE] ; VarFree 
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse242

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(15)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(15)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [fvar_tbl+34*WORD_SIZE] ; VarFree 
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	jmp LexitIf242

Lelse242:
	mov rax, const_tbl+2 ; Const 


LexitIf242:
	jmp LexitIf241

Lelse241:
	mov rax, const_tbl+2 ; Const 


LexitIf241:
	jmp LexitIf240

Lelse240:
	mov rax, const_tbl+2 ; Const 


LexitIf240:
	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr229


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(10)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse251

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(10)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse252

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(16)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(16)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(1)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	jmp LexitIf252

Lelse252:
	mov rax, const_tbl+2 ; Const 


LexitIf252:
	jmp LexitIf251

Lelse251:
	mov rax, const_tbl+2 ; Const 


LexitIf251:
	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr229


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(11)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse258

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(11)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse259

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(3)  
	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(4)  
	push rax 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 4 ; <nArgs> 
	push 4 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	jmp LexitIf259

Lelse259:
	mov rax, const_tbl+2 ; Const 


LexitIf259:
	jmp LexitIf258

Lelse258:
	mov rax, const_tbl+2 ; Const 


LexitIf258:
	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr229


	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(12)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse263

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rcx, 1 ; <nArgs> 
	push 1 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(12)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	cmp rax, SOB_FALSE_ADDRESS
	je Lelse264

	mov rax, 6666 ; applic 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(6)  
	push rax 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(5)  
	push rax 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 4 ; <nArgs> 
	push 4 ; parse <op> below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(0) 
	mov rax, BVAR(0)  
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	jmp LexitIf264

Lelse264:
	mov rax, const_tbl+2 ; Const 


LexitIf264:
	jmp LexitIf263

Lelse263:
	mov rax, const_tbl+2 ; Const 


LexitIf263:
	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr229

	mov rax, 6666 ; applic tail position 
	push rax ; 6666 As Magic, At the End of Args 
	mov rax, PVAR(1) ; VarParam 
	push rax 
	mov rax, PVAR(0) ; VarParam 
	push rax 
	mov rcx, 2 ; <nArgs> 
	push 2 ; parsing of operator below: 
	mov rax, qword [rbp + 16] ; VarBound 
	mov rax, BVAR(1) 
	mov rax, BVAR(13)  
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 7
	mov rbp, r15 
	jmp r10 ; code 

	cmp rax, SOB_FALSE_ADDRESS
	jne LexitOr229

	LexitOr229:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont228:
	leave ; done parsing lambdaSimple body above 
	ret 

Lcont227:
	mov r9, [rax+TYPE_SIZE] ; env 
	push r9 
	mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	push qword [rbp + 8] ; old ret addr 
	mov r15, qword[rbp] 
	SHIFT_FRAME 6
	mov rbp, r15 
	jmp r10 ; code 

	leave ; done parsing lambdaSimple body above 
	ret 

Lcont226:
	mov rbx, [rax+TYPE_SIZE] ; env 
	push rbx ; push env 
	mov rbx, [rax+TYPE_SIZE+WORD_SIZE] ; code 
	call rbx ; call code
 	add rsp, 8*1 ; pop env 
	pop rbx ; pop arg count 
	inc rbx 
	shl rbx, 3 ; rbx = rbx * 8 
	add rsp, rbx ; pop args 

	mov qword [fvar_tbl+34*WORD_SIZE], rax ; define 
	mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

	mov rax, const_tbl+118 ; Const 
	call write_sob_if_not_void
	add rsp, 4*8 
	pop rbp 
	ret 


apply:
    push rbp
    mov rbp, rsp
    
    mov rcx, 2

.get_list:
    mov r14, PVAR(rcx) 
    cmp r14, 6666
    je .got_list
    inc rcx
    jmp .get_list 

    dec rcx

.got_list:
    dec rcx 
    mov r14, PVAR(rcx) ; List
    mov r11, r14 ; Init
    mov rdx, 1 ; Init <lenList>
    push 6666 ; Magic

.push_list:
    cmp r11, const_tbl+1 
    je .non_empty
	CAR r10, r14
    CDR r11, r14
    push r10
    mov r14, r11
    inc rdx
    jmp .push_list


.non_empty:
    mov r10, rsp
    mov r11, rbp
    add r11, -16 ; prep swap

.reverse:
    cmp r10, r11
    jg .finish
    mov r12, qword[r10] ; swap
    mov r13, qword[r11]
    mov qword[r10], r13
    mov qword[r11], r12
    add r10, 8 ; inc 
    add r11, -8 ; dec
    jmp .reverse

.finish:
    dec rcx
    add rdx, rcx ; oldLen + listLen - 1
    dec rdx
    
    cmp rcx, 0
    jle .prep_call ; no Args before List

.push_args:
    mov rax, PVAR(rcx) 
    push rax 
    cmp rcx, 1
    je .prep_call
    dec rcx
    jmp .push_args

.prep_call:
    push rdx ; <newNumArgs>
    mov rax, PVAR(0)
    mov r9, [rax + TYPE_SIZE] ; env 
    push r9 ; push
    mov r10, [rax+TYPE_SIZE+WORD_SIZE] ; code 
    push qword [rbp + 8] ; old ret addr
    mov r15, qword[rbp] ; Save rbp
    add rdx, 5 ; <newLen> + 5
    
    ; Macro Shift_Frame
	push rax
	mov r9, PARAM_COUNT ; prevLen + 5
	mov rax, r9
	add rax, 5
    mov r11, 1
    
.shift: ; # <rdx> times
	dec rax
    mov r12, r11 ; idxLoop
    shl r12, 3 
    mov r13, rbp
    sub r13, r12 ; rbp - 8 * idxLoop
    mov r8, qword[r13]
	mov [rbp + WORD_SIZE * rax], r8
    cmp r11, rdx
    je .end_shift
    inc r11
    jmp .shift

.end_shift:
	pop rax
	mov r8, r9
	add r8, 5
	shl r8, 3
	add rsp, r8 ; End Macro

    mov rbp, r15 ; Restore rbp
    jmp r10 ; code
  
.return:
    leave
    ret


is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_vector:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_VECTOR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

vector_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    VECTOR_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

vector_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    VECTOR_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 3
    add rsi, rdi

    mov rax, [rsi]

    leave
    ret

vector_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    VECTOR_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 3
    add rsi, rdi

    mov rdi, PVAR(2)
    mov [rsi], rdi
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_vector:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    

    MAKE_VECTOR rax, rsi, rdi

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

.loop:
    cmp rcx, 0
    je .end
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    dec rcx
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret


 
car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ; rsi got pair
	CAR rax, rsi ; rax got car
    jmp .return

.return:
    leave
    ret

cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
	CDR rax, rsi
    jmp .return

.return:
    leave
    ret
    
set_car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(1) ; rsi got new car
    mov r8, PVAR(0) ; qword of pair
    add r8, 1 ; r8 is car loc
    mov [r8], rsi
    mov r9, qword [r8] ; r9 is car val

    mov rax, SOB_VOID_ADDRESS
    jmp .return

.return:
    leave
    ret

set_cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(1) ; rsi got new car
    mov r8, PVAR(0) ; qword of pair
    add r8, 9 ; r8 is cdr loc
    mov [r8], rsi
    mov r9, qword [r8] ; r9 is car val

    mov rax, SOB_VOID_ADDRESS
    jmp .return

.return:
    leave
    ret

cons:
    push rbp
    mov rbp, rsp

    mov r8, PVAR(0) ; car
    mov r9, PVAR(1) ; cdr
    MAKE_PAIR (rax, r8, r9) ; pair into rax

    jmp .return

.return:
    leave
    ret  
