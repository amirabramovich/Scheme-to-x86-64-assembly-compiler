
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
malloc_pointer:
    resq 1

section .data
const_tbl:
MAKE_VOID ; my address is 0
MAKE_NIL ; my address is 1
MAKE_BOOL(0) ; my address is 2
MAKE_BOOL(1) ; my address is 4
MAKE_LITERAL_STRING "p" ; my address is 6
MAKE_LITERAL_STRING "c" ; my address is 16
MAKE_LITERAL_STRING "n" ; my address is 26
MAKE_LITERAL_STRING "z" ; my address is 36
MAKE_LITERAL_STRING "s" ; my address is 46
MAKE_LITERAL_STRING "a" ; my address is 56
MAKE_LITERAL_STRING "b" ; my address is 66
MAKE_LITERAL_STRING "y" ; my address is 76
MAKE_LITERAL_STRING "x" ; my address is 86

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl + 0
%define SOB_NIL_ADDRESS const_tbl + 1
%define SOB_FALSE_ADDRESS const_tbl + 2
%define SOB_TRUE_ADDRESS const_tbl + 4

fvar_tbl:
dq T_UNDEFINED ; i'm boolean?, my address is 0
dq T_UNDEFINED ; i'm float?, my address is 1
dq T_UNDEFINED ; i'm integer?, my address is 2
dq T_UNDEFINED ; i'm pair?, my address is 3
dq T_UNDEFINED ; i'm null?, my address is 4
dq T_UNDEFINED ; i'm char?, my address is 5
dq T_UNDEFINED ; i'm vector?, my address is 6
dq T_UNDEFINED ; i'm string?, my address is 7
dq T_UNDEFINED ; i'm procedure?, my address is 8
dq T_UNDEFINED ; i'm symbol?, my address is 9
dq T_UNDEFINED ; i'm string-length, my address is 10
dq T_UNDEFINED ; i'm string-ref, my address is 11
dq T_UNDEFINED ; i'm string-set!, my address is 12
dq T_UNDEFINED ; i'm make-string, my address is 13
dq T_UNDEFINED ; i'm vector-length, my address is 14
dq T_UNDEFINED ; i'm vector-ref, my address is 15
dq T_UNDEFINED ; i'm vector-set!, my address is 16
dq T_UNDEFINED ; i'm make-vector, my address is 17
dq T_UNDEFINED ; i'm symbol->string, my address is 18
dq T_UNDEFINED ; i'm char->integer, my address is 19
dq T_UNDEFINED ; i'm integer->char, my address is 20
dq T_UNDEFINED ; i'm eq?, my address is 21
dq T_UNDEFINED ; i'm +, my address is 22
dq T_UNDEFINED ; i'm *, my address is 23
dq T_UNDEFINED ; i'm -, my address is 24
dq T_UNDEFINED ; i'm /, my address is 25
dq T_UNDEFINED ; i'm <, my address is 26
dq T_UNDEFINED ; i'm =, my address is 27
dq T_UNDEFINED ; i'm car, my address is 28
dq T_UNDEFINED ; i'm cdr, my address is 29
dq T_UNDEFINED ; i'm set-car!, my address is 30
dq T_UNDEFINED ; i'm set-cdr!, my address is 31
dq T_UNDEFINED ; i'm cons, my address is 32

global main
section .text
main:
    push rbp 
    mov rbp, rsp

    ;; set up the heap
    mov rdi, MB(500) ;; TODO: changed from GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp

    jmp code_fragment

code_fragment:
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [fvar_tbl + 0 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [fvar_tbl + 1 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [fvar_tbl + 2 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [fvar_tbl + 3 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [fvar_tbl + 4 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [fvar_tbl + 5 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_vector)
    mov [fvar_tbl + 6 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [fvar_tbl + 7 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [fvar_tbl + 8 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [fvar_tbl + 9 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [fvar_tbl + 10 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [fvar_tbl + 11 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [fvar_tbl + 12 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [fvar_tbl + 13 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_length)
    mov [fvar_tbl + 14 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_ref)
    mov [fvar_tbl + 15 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_set)
    mov [fvar_tbl + 16 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_vector)
    mov [fvar_tbl + 17 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [fvar_tbl + 18 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [fvar_tbl + 19 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [fvar_tbl + 20 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [fvar_tbl + 21 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [fvar_tbl + 22 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [fvar_tbl + 23 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [fvar_tbl + 24 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [fvar_tbl + 25 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [fvar_tbl + 26 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [fvar_tbl + 27 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
    mov [fvar_tbl + 28 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
    mov [fvar_tbl + 29 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
    mov [fvar_tbl + 30 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
    mov [fvar_tbl + 31 * WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
    mov [fvar_tbl + 32 * WORD_SIZE], rax
    
user_code:

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, const_tbl + 2 ; Const 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, const_tbl + 4 ; Const 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple130:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 0 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode130)
		jmp Lcont130

	Lcode130:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple131:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode131)
		jmp Lcont131

	Lcode131:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont131:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont130:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple128:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 0 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode128)
		jmp Lcont128

	Lcode128:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple129:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode129)
		jmp Lcont129

	Lcode129:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont129:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont128:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple126:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 0 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode126)
		jmp Lcont126

	Lcode126:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple127:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode127)
		jmp Lcont127

	Lcode127:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont127:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont126:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple124:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 0 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode124)
		jmp Lcont124

	Lcode124:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple125:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode125)
		jmp Lcont125

	Lcode125:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont125:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont124:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple115:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 0 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode115)
		jmp Lcont115

	Lcode115:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple116:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode116)
		jmp Lcont116

	Lcode116:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple122:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode122)
		jmp Lcont122

	Lcode122:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple123:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode123)
		jmp Lcont123

	Lcode123:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont123:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont122:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple117:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode117)
		jmp Lcont117

	Lcode117:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple118:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode118)
		jmp Lcont118

	Lcode118:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple119:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode119)
		jmp Lcont119

	Lcode119:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple120:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode120)
		jmp Lcont120

	Lcode120:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple121:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode121)
		jmp Lcont121

	Lcode121:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont121:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont120:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont119:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont118:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont117:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont116:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont115:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple106:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 0 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode106)
		jmp Lcont106

	Lcode106:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple107:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode107)
		jmp Lcont107

	Lcode107:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple113:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode113)
		jmp Lcont113

	Lcode113:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple114:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode114)
		jmp Lcont114

	Lcode114:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont114:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont113:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple108:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode108)
		jmp Lcont108

	Lcode108:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple109:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode109)
		jmp Lcont109

	Lcode109:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple110:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode110)
		jmp Lcont110

	Lcode110:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple111:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode111)
		jmp Lcont111

	Lcode111:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple112:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode112)
		jmp Lcont112

	Lcode112:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont112:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont111:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont110:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont109:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont108:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont107:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont106:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple104:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 0 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode104)
		jmp Lcont104

	Lcode104:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple105:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode105)
		jmp Lcont105

	Lcode105:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont105:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont104:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple70:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 0 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode70)
		jmp Lcont70

	Lcode70:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple103:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode103)
		jmp Lcont103

	Lcode103:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont103:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple102:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode102)
		jmp Lcont102

	Lcode102:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont102:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple99:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode99)
		jmp Lcont99

	Lcode99:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple100:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode100)
		jmp Lcont100

	Lcode100:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple101:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode101)
		jmp Lcont101

	Lcode101:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont101:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont100:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont99:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple74:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode74)
		jmp Lcont74

	Lcode74:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple96:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode96)
		jmp Lcont96

	Lcode96:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple97:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode97)
		jmp Lcont97

	Lcode97:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple98:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode98)
		jmp Lcont98

	Lcode98:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont98:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont97:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont96:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple93:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode93)
		jmp Lcont93

	Lcode93:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple94:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode94)
		jmp Lcont94

	Lcode94:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple95:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode95)
		jmp Lcont95

	Lcode95:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont95:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont94:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont93:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple84:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode84)
		jmp Lcont84

	Lcode84:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple85:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode85)
		jmp Lcont85

	Lcode85:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple91:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode91)
		jmp Lcont91

	Lcode91:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple92:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode92)
		jmp Lcont92

	Lcode92:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont92:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont91:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple86:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode86)
		jmp Lcont86

	Lcode86:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple87:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode87)
		jmp Lcont87

	Lcode87:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple88:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode88)
		jmp Lcont88

	Lcode88:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple89:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode89)
		jmp Lcont89

	Lcode89:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple90:
	MALLOC r10, 8 * (1 + 8) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 8 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode90)
		jmp Lcont90

	Lcode90:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont90:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont89:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont88:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont87:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont86:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont85:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont84:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple81:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode81)
		jmp Lcont81

	Lcode81:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple82:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode82)
		jmp Lcont82

	Lcode82:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple83:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode83)
		jmp Lcont83

	Lcode83:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont83:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont82:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont81:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple78:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode78)
		jmp Lcont78

	Lcode78:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple79:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode79)
		jmp Lcont79

	Lcode79:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple80:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode80)
		jmp Lcont80

	Lcode80:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont80:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont79:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont78:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple75:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode75)
		jmp Lcont75

	Lcode75:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple76:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode76)
		jmp Lcont76

	Lcode76:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple77:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode77)
		jmp Lcont77

	Lcode77:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont77:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont76:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont75:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont74:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple71:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode71)
		jmp Lcont71

	Lcode71:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple72:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode72)
		jmp Lcont72

	Lcode72:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple73:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode73)
		jmp Lcont73

	Lcode73:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont73:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont72:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont71:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont70:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple0:
	MALLOC r10, 8 * (1 + 0) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 0 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*0 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 0 ; 0 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode0)
		jmp Lcont0

	Lcode0:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple1:
	MALLOC r10, 8 * (1 + 1) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 1 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode1)
		jmp Lcont1

	Lcode1:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple44:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode44)
		jmp Lcont44

	Lcode44:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple45:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode45)
		jmp Lcont45

	Lcode45:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple46:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode46)
		jmp Lcont46

	Lcode46:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple68:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode68)
		jmp Lcont68

	Lcode68:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple69:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode69)
		jmp Lcont69

	Lcode69:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont69:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont68:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple66:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode66)
		jmp Lcont66

	Lcode66:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple67:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode67)
		jmp Lcont67

	Lcode67:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont67:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont66:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple63:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode63)
		jmp Lcont63

	Lcode63:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple64:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode64)
		jmp Lcont64

	Lcode64:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple65:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode65)
		jmp Lcont65

	Lcode65:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont65:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont64:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont63:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple50:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode50)
		jmp Lcont50

	Lcode50:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple60:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode60)
		jmp Lcont60

	Lcode60:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple61:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode61)
		jmp Lcont61

	Lcode61:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple62:
	MALLOC r10, 8 * (1 + 8) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 8 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode62)
		jmp Lcont62

	Lcode62:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont62:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont61:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont60:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple57:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode57)
		jmp Lcont57

	Lcode57:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple58:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode58)
		jmp Lcont58

	Lcode58:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple59:
	MALLOC r10, 8 * (1 + 8) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 8 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode59)
		jmp Lcont59

	Lcode59:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont59:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont58:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont57:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple54:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode54)
		jmp Lcont54

	Lcode54:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple55:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode55)
		jmp Lcont55

	Lcode55:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple56:
	MALLOC r10, 8 * (1 + 8) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 8 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode56)
		jmp Lcont56

	Lcode56:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont56:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont55:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont54:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple51:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode51)
		jmp Lcont51

	Lcode51:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple52:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode52)
		jmp Lcont52

	Lcode52:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple53:
	MALLOC r10, 8 * (1 + 8) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 8 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode53)
		jmp Lcont53

	Lcode53:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont53:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont52:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont51:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont50:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple47:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode47)
		jmp Lcont47

	Lcode47:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple48:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode48)
		jmp Lcont48

	Lcode48:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple49:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode49)
		jmp Lcont49

	Lcode49:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont49:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont48:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont47:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont46:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont45:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont44:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple38:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode38)
		jmp Lcont38

	Lcode38:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple42:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode42)
		jmp Lcont42

	Lcode42:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple43:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode43)
		jmp Lcont43

	Lcode43:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont43:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont42:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple39:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode39)
		jmp Lcont39

	Lcode39:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple40:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode40)
		jmp Lcont40

	Lcode40:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple41:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode41)
		jmp Lcont41

	Lcode41:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont41:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont40:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont39:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont38:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple12:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode12)
		jmp Lcont12

	Lcode12:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple13:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode13)
		jmp Lcont13

	Lcode13:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple14:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode14)
		jmp Lcont14

	Lcode14:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple36:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode36)
		jmp Lcont36

	Lcode36:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple37:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode37)
		jmp Lcont37

	Lcode37:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont37:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont36:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple34:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode34)
		jmp Lcont34

	Lcode34:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple35:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode35)
		jmp Lcont35

	Lcode35:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont35:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont34:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple31:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode31)
		jmp Lcont31

	Lcode31:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple32:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode32)
		jmp Lcont32

	Lcode32:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple33:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode33)
		jmp Lcont33

	Lcode33:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont33:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont32:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont31:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple18:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode18)
		jmp Lcont18

	Lcode18:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple28:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode28)
		jmp Lcont28

	Lcode28:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple29:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode29)
		jmp Lcont29

	Lcode29:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple30:
	MALLOC r10, 8 * (1 + 8) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 8 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode30)
		jmp Lcont30

	Lcode30:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont30:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont29:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont28:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple25:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode25)
		jmp Lcont25

	Lcode25:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple26:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode26)
		jmp Lcont26

	Lcode26:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple27:
	MALLOC r10, 8 * (1 + 8) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 8 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode27)
		jmp Lcont27

	Lcode27:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont27:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont26:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont25:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple22:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode22)
		jmp Lcont22

	Lcode22:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple23:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode23)
		jmp Lcont23

	Lcode23:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple24:
	MALLOC r10, 8 * (1 + 8) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 8 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode24)
		jmp Lcont24

	Lcode24:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont24:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont23:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont22:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple19:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode19)
		jmp Lcont19

	Lcode19:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple20:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode20)
		jmp Lcont20

	Lcode20:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple21:
	MALLOC r10, 8 * (1 + 8) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 8 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode21)
		jmp Lcont21

	Lcode21:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(1)
	mov rax, BVAR(0)
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont21:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont20:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont19:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont18:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple15:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode15)
		jmp Lcont15

	Lcode15:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple16:
	MALLOC r10, 8 * (1 + 6) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 6 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode16)
		jmp Lcont16

	Lcode16:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple17:
	MALLOC r10, 8 * (1 + 7) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 7 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode17)
		jmp Lcont17

	Lcode17:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont17:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont16:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont15:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont14:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont13:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont12:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple6:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode6)
		jmp Lcont6

	Lcode6:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple10:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode10)
		jmp Lcont10

	Lcode10:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple11:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode11)
		jmp Lcont11

	Lcode11:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont11:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont10:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple7:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode7)
		jmp Lcont7

	Lcode7:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple8:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode8)
		jmp Lcont8

	Lcode8:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple9:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode9)
		jmp Lcont9

	Lcode9:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont9:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont8:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont7:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont6:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	lambdaSimple2:
	MALLOC r10, 8 * (1 + 2) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 2 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode2)
		jmp Lcont2

	Lcode2:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple3:
	MALLOC r10, 8 * (1 + 3) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 3 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode3)
		jmp Lcont3

	Lcode3:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 

	lambdaSimple4:
	MALLOC r10, 8 * (1 + 4) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 4 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode4)
		jmp Lcont4

	Lcode4:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 

	lambdaSimple5:
	MALLOC r10, 8 * (1 + 5) ; Allocate ExtEnv
	mov r11, r10 ; copy of ExtEnv address
	mov r12, 0 ; i
	mov r13, 1 ; j
	mov r15, qword[rbp + 16] ; lexical env

	.copy_env:
		cmp r12, 5 ; |env|
		je .done_copy_env
		mov r14, qword[r15 + 8 * r12] ; r14 = Env[i]
		mov [r11 + 8 * r13], r14 ; ExtEnv[j] = r14
		inc r12 ; inc counter of loop
		inc r13 ; inc counter of loop
		jmp .copy_env ; back to loop

	.done_copy_env:
		mov r12, 0 ; i
		mov r15, rbp ; r15 = rbp
		add r15, 32 ; r15 = address of first arg
		MALLOC r14, 8*1 ; allocate ExtEnv[0]
		mov r11, r14 ; copy of ExtEnv[0] 

	.copy_params:
		cmp r12, 1 ; 1 arguments
		je .done_copy_params
		mov r9, [r15] ; r9 = Param(i)
		mov [r14], r9 ; ExtEnv [0][i] = r9
		add r14, 8
		add r15, 8
		inc r12
		jmp .copy_params

	.done_copy_params:
		mov [r10], r11
		MAKE_CLOSURE(rax, r10, Lcode5)
		jmp Lcont5

	Lcode5:
	push rbp
	mov rbp , rsp ; parse of lambdaSimple body below: 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont5:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont4:
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 

	mov rax, MAGIC ; Applic 
	push rax ; push magic to stack 
	mov rax, PVAR(0) ; Var' or Box' of VarParam 
	mov r15, IS_PARAM ; for sign in ApplicTP, that this arg is param 
	push rax ; push arg 
	push 1 ; push number args 
	; start parse op 
	mov rax, qword [rbp + 16] ; Var' or Box' of VarBound 
	mov rax, BVAR(0)
	mov rax, BVAR(0)
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont3:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont2:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	leave ; done parsing lambdaSimple body above 
	ret

	Lcont1:
	leave ; done parsing lambdaSimple body above 
	ret

	Lcont0:
	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

	; finish parse op 
 	mov rbx, [rax + TYPE_SIZE] ; closure's env to rbx 
	push rbx ; push env (args) to stack (rsp stack pointer) 
	mov rbx, [rax + TYPE_SIZE + WORD_SIZE] ; clousre's code to rbx 
	call rbx ; call code (of closure) 
	add rsp, 8*1 ; pop env (args) 
	pop rbx ; pop number args 
	inc rbx ; add magic as param (in counter) for pop 
	shl rbx, 3 ; rbx = rbx * 8 (calc size args) 
	add rsp, rbx ; pop args 

    call write_sob_if_not_void
	add rsp, 4*8 
	pop rbp 
	ret 


is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_vector:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_VECTOR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

vector_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    VECTOR_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

vector_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    VECTOR_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 3
    add rsi, rdi

    mov rax, [rsi]

    leave
    ret

vector_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    VECTOR_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 3
    add rsi, rdi

    mov rdi, PVAR(2)
    mov [rsi], rdi
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_vector:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    

    MAKE_VECTOR rax, rsi, rdi

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

.loop:
    cmp rcx, 0
    je .end
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    dec rcx
    jmp .loop ;; due to Yitav comment on facebook
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret


 
car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ;; rsi got pair
	CAR rax, rsi ;; rax got car
    jmp .return

.return:
    leave
    ret

cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
	CDR rax, rsi
    jmp .return

.return:
    leave
    ret
    
set_car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(1) ;; rsi contains new car
    mov r8, PVAR(0) ;; qword of pair
    add r8, 1 ;; r8 is car loc
    mov [r8], rsi
    mov r9, qword [r8] ;; r9 is car val

    mov rax, SOB_VOID_ADDRESS
    jmp .return

.return:
    leave
    ret

set_cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(1) ;; rsi contains new car
    mov r8, PVAR(0) ;; qword of pair
    add r8, 9 ;; r8 is cdr loc
    mov [r8], rsi
    mov r9, qword [r8] ;; r9 is car val

    mov rax, SOB_VOID_ADDRESS
    jmp .return

.return:
    leave
    ret

cons:
    push rbp
    mov rbp, rsp

    mov r8, PVAR(0) ;; car
    mov r9, PVAR(1) ;; cdr
    MAKE_PAIR (rax, r8, r9) ;; put pair into rax, r8 is car, r9 is cdr

    jmp .return

.return:
    leave
    ret    
